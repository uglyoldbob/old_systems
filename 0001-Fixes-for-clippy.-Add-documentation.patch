From d4044d79b99eb31681e57a28a0022642a7318580 Mon Sep 17 00:00:00 2001
From: Thomas Epperson <thomas.epperson@snapon.com>
Date: Tue, 21 Mar 2023 14:25:28 -0500
Subject: [PATCH] Fixes for clippy. Add documentation. Remove some unused
 fields.

---
 nes/rust/src/apu.rs                |   145 +-
 nes/rust/src/benchmark.rs          |    22 +-
 nes/rust/src/cartridge.rs          |   107 +-
 nes/rust/src/cartridge/mapper00.rs |    14 +-
 nes/rust/src/cartridge/mapper01.rs |    68 +-
 nes/rust/src/cartridge/mapper03.rs |    12 +-
 nes/rust/src/controller.rs         |    25 +-
 nes/rust/src/cpu.rs                | 13671 +++++++++++++--------------
 nes/rust/src/emulator_data.rs      |    31 +-
 nes/rust/src/main.rs               |   102 +-
 nes/rust/src/motherboard.rs        |    35 +-
 nes/rust/src/ppu.rs                |   210 +-
 nes/rust/src/romlist.rs            |    34 +-
 nes/rust/src/utility.rs            |     1 +
 14 files changed, 7251 insertions(+), 7226 deletions(-)

diff --git a/nes/rust/src/apu.rs b/nes/rust/src/apu.rs
index 87b5bdd..68c3c04 100644
--- a/nes/rust/src/apu.rs
+++ b/nes/rust/src/apu.rs
@@ -1,14 +1,20 @@
+//! Responsible for emulating the details of the audio processing (apu) of the nes console.
+
 use biquad::Biquad;
 use rb::RbProducer;
 
+/// A square channel for the apu
 #[non_exhaustive]
 #[derive(serde::Serialize, serde::Deserialize)]
 struct ApuSquareChannel {
+    /// The length of the channel for playback
     length: u8,
+    /// The counter for the channel
     counter: u8,
 }
 
 impl ApuSquareChannel {
+    /// Create a new square channel for the apu
     fn new() -> Self {
         Self {
             length: 0,
@@ -16,21 +22,27 @@ impl ApuSquareChannel {
         }
     }
 
+    /// Clock the channel
     fn cycle(&mut self) {}
 
+    /// Return the audio sample for this channel
     fn audio(&self) -> f32 {
         self.counter as f32
     }
 }
 
+/// A noise channel for the apu
 #[non_exhaustive]
 #[derive(serde::Serialize, serde::Deserialize)]
 struct ApuNoiseChannel {
+    /// The length of the channel
     length: u8,
+    /// The counter for the channel
     counter: u8,
 }
 
 impl ApuNoiseChannel {
+    /// Create a new channel
     fn new() -> Self {
         Self {
             length: 0,
@@ -38,21 +50,27 @@ impl ApuNoiseChannel {
         }
     }
 
+    /// clock the channel
     fn cycle(&mut self) {}
 
+    /// Return the audio sample for this channel
     fn audio(&self) -> f32 {
         self.counter as f32
     }
 }
 
+/// A triangle channel for the apu
 #[non_exhaustive]
 #[derive(serde::Serialize, serde::Deserialize)]
 struct ApuTriangleChannel {
+    /// The length of the channel for playback
     length: u8,
+    /// The counter for the channel
     counter: u8,
 }
 
 impl ApuTriangleChannel {
+    /// Create a new triangle channel
     fn new() -> Self {
         Self {
             length: 0,
@@ -60,35 +78,55 @@ impl ApuTriangleChannel {
         }
     }
 
+    /// Clock the channel
     fn cycle(&mut self) {}
 
+    /// Return the audio sample for this channel
     fn audio(&self) -> f32 {
         self.counter as f32
     }
 }
 
+/// A dmc channel for the apu
 #[non_exhaustive]
 #[derive(serde::Serialize, serde::Deserialize)]
 struct ApuDmcChannel {
+    /// The interrupt flag
     interrupt_flag: bool,
+    /// The interrupt is enabled
     interrupt_enable: bool,
+    /// Used for addressinng the individual bits of the audio sample
     bit_counter: u8,
+    /// The programmed rate for the channel
     rate: u16,
+    /// The counter for the divider used in the channel
     rate_counter: u16,
+    /// The programmed length for the channel
     programmed_length: u16,
+    /// Length parameter for playback
     length: u16,
+    /// The sample buffer to play from
     sample_buffer: Option<u8>,
+    /// The contents of the shift register
     shift_register: u8,
+    /// The potential address for a dma request
     dma_request: Option<u16>,
+    /// The result of a dma operation
     dma_result: Option<u8>,
+    /// The address to use for dma
     dma_address: u16,
+    /// True when the channel is looping
     loop_flag: bool,
+    /// True when the channel is playing
     playing: bool,
+    /// True when the channel is silent
     silence: bool,
+    /// The stored output for the channel
     output: u8,
 }
 
 impl ApuDmcChannel {
+    /// Create a new dmc channel
     fn new() -> Self {
         Self {
             interrupt_flag: false,
@@ -110,6 +148,7 @@ impl ApuDmcChannel {
         }
     }
 
+    ///Clock the dmc channel
     fn cycle(&mut self, _timing: u32) {
         if self.sample_buffer.is_none() && self.dma_request.is_none() && self.length > 0 {
             self.dma_request = Some(self.dma_address | 0x8000);
@@ -138,33 +177,46 @@ impl ApuDmcChannel {
         //println!("DMC CYCLE {} {}", self.rate_counter, self.bit_counter);
     }
 
+    /// Return the audio sample for this channel
     fn audio(&self) -> f32 {
         self.output as f32
     }
 }
 
+/// The nes apu
 #[non_exhaustive]
 #[derive(serde::Serialize, serde::Deserialize)]
 pub struct NesApu {
+    /// Used to divide the input clock by 2
     clock: bool,
+    /// The registers for the apu
     registers: [u8; 24],
+    /// The two square audio channels
     squares: [ApuSquareChannel; 2],
+    /// The noise audio channel
     noise: ApuNoiseChannel,
+    /// The triangle audio channel
     triangle: ApuTriangleChannel,
+    /// The dmc audio channel
     dmc: ApuDmcChannel,
+    /// The counter for the frame sequencer
     frame_sequencer_clock: u32,
+    /// Variable used for the operation of the frame sequencer
     frame_sequencer_reset: u8,
+    /// This flag disables sound on startup
     sound_disabled: bool,
+    /// The timer for disabling sound on startup
     sound_disabled_clock: u16,
-    read_count: u8,
-    cycles: u32,
+    /// The timing clock used by the dmc channel
     timing_clock: u32,
-    last_sample_rate: f32,
+    /// The index for generating audio samples
     output_index: f32,
+    /// The number of slow clock cycles between audio samples
     sample_interval: f32,
 }
 
 impl NesApu {
+    /// Build a new apu
     pub fn new() -> Self {
         Self {
             clock: false,
@@ -177,15 +229,13 @@ impl NesApu {
             frame_sequencer_reset: 0,
             sound_disabled: true,
             sound_disabled_clock: 0,
-            read_count: 0,
-            cycles: 0,
             timing_clock: 0,
-            last_sample_rate: 0.0,
             output_index: 0.0,
             sample_interval: 100.0,
         }
     }
 
+    /// Reset the apu
     pub fn reset(&mut self) {
         self.registers[0x15] = 0;
         self.sound_disabled = true;
@@ -193,14 +243,18 @@ impl NesApu {
         self.frame_sequencer_reset = 2;
     }
 
+    /// Get the irq line for the apu
     pub fn irq(&self) -> bool {
         (self.registers[0x15] & 0xc0) != 0 && (self.registers[0x17] & 0x40) == 0
     }
 
+    /// Get the dmc dma request
     pub fn dma(&self) -> Option<u16> {
         self.dmc.dma_request
     }
 
+    /// Used by the cpu to provide the dma response from the cpu
+    /// Used by the dmc channel
     pub fn provide_dma_response(&mut self, data: u8) {
         self.dmc.dma_request = None;
         self.dmc.sample_buffer = Some(data);
@@ -209,20 +263,20 @@ impl NesApu {
         if self.dmc.length == 0 {
             if self.dmc.loop_flag {
                 self.dmc.length = self.dmc.programmed_length;
-            } else {
-                if self.dmc.interrupt_enable {
-                    self.dmc.interrupt_flag = true;
-                }
+            } else if self.dmc.interrupt_enable {
+                self.dmc.interrupt_flag = true;
             }
         }
     }
 
+    /// Set the interrupt flag from the frame sequencer
     fn set_interrupt_flag(&mut self) {
         if (self.registers[0x17] & 0x40) == 0 {
             self.registers[0x15] |= 0x40;
         }
     }
 
+    /// Operate the frame sequencer
     fn frame_sequencer_clock(&mut self) {
         if !self.clock {
             if self.frame_sequencer_reset > 0 {
@@ -237,19 +291,13 @@ impl NesApu {
             if self.frame_sequencer_clock == 14915 {
                 self.set_interrupt_flag();
                 self.frame_sequencer_clock = 0;
-            } else if self.frame_sequencer_clock == 3728 {
-                if self.clock {
-                    self.quarter_frame();
-                }
-            } else if self.frame_sequencer_clock == 7456 {
-                if self.clock {
-                    self.quarter_frame();
-                    self.half_frame();
-                }
-            } else if self.frame_sequencer_clock == 11185 {
-                if self.clock {
-                    self.quarter_frame();
-                }
+            } else if self.frame_sequencer_clock == 3728 && self.clock {
+                self.quarter_frame();
+            } else if self.frame_sequencer_clock == 7456 && self.clock {
+                self.quarter_frame();
+                self.half_frame();
+            } else if self.frame_sequencer_clock == 11185 && self.clock {
+                self.quarter_frame();
             } else if self.frame_sequencer_clock == 14914 {
                 self.set_interrupt_flag();
                 if self.clock {
@@ -261,24 +309,16 @@ impl NesApu {
             //5 step sequence
             if self.frame_sequencer_clock == 18641 {
                 self.frame_sequencer_clock = 0;
-            } else if self.frame_sequencer_clock == 3728 {
-                if self.clock {
-                    self.quarter_frame();
-                }
-            } else if self.frame_sequencer_clock == 7456 {
-                if self.clock {
-                    self.quarter_frame();
-                    self.half_frame();
-                }
-            } else if self.frame_sequencer_clock == 11185 {
-                if self.clock {
-                    self.quarter_frame();
-                }
-            } else if self.frame_sequencer_clock == 18640 {
-                if self.clock {
-                    self.quarter_frame();
-                    self.half_frame();
-                }
+            } else if self.frame_sequencer_clock == 3728 && self.clock {
+                self.quarter_frame();
+            } else if self.frame_sequencer_clock == 7456 && self.clock {
+                self.quarter_frame();
+                self.half_frame();
+            } else if self.frame_sequencer_clock == 11185 && self.clock {
+                self.quarter_frame();
+            } else if self.frame_sequencer_clock == 18640 && self.clock {
+                self.quarter_frame();
+                self.half_frame();
             }
         }
         if self.clock {
@@ -286,10 +326,12 @@ impl NesApu {
         }
     }
 
+    /// The quarter frame, as determined by the frame sequencer
     fn quarter_frame(&mut self) {
         //TODO clock the envelopes, and triangle linear counter
     }
 
+    /// The half frame, as determined by the frame sequencer
     fn half_frame(&mut self) {
         //TODO clock the length counters and sweep units
         //first square length counter
@@ -314,10 +356,12 @@ impl NesApu {
         }
     }
 
+    /// Set the interval between audio samples
     pub fn set_audio_interval(&mut self, interval: f32) {
         self.sample_interval = interval;
     }
 
+    /// Build an audio sample and run the audio filter
     fn build_audio_sample(&mut self, filter: &mut Option<biquad::DirectForm1<f32>>) -> Option<f32> {
         let audio = self.squares[0].audio()
             + self.squares[1].audio()
@@ -338,14 +382,15 @@ impl NesApu {
         }
     }
 
+    /// Clock the apu, this used to do something, now it doesn't
     pub fn clock_slow_pre(&mut self) {}
 
+    /// Clock the apu
     pub fn clock_slow(
         &mut self,
         sound: &mut Option<rb::Producer<f32>>,
         filter: &mut Option<biquad::DirectForm1<f32>>,
     ) {
-        self.cycles = self.cycles.wrapping_add(1);
         self.frame_sequencer_clock();
         if self.clock {
             self.timing_clock = self.timing_clock.wrapping_add(1);
@@ -370,15 +415,18 @@ impl NesApu {
         }
     }
 
+    /// A lookup table for setting the length of the audio channels
     const LENGTH_TABLE: [u8; 32] = [
         10, 254, 20, 2, 40, 4, 80, 6, 160, 8, 60, 10, 14, 12, 26, 14, 12, 16, 24, 18, 48, 20, 96,
         22, 192, 24, 72, 26, 16, 28, 32, 30,
     ];
 
+    /// A lookup table for setting the dmc rates
     const DMC_RATE_TABLE: [u16; 16] = [
         428, 380, 340, 320, 286, 254, 226, 214, 190, 160, 142, 128, 106, 84, 72, 54,
     ];
 
+    /// Write to an apu register
     pub fn write(&mut self, addr: u16, data: u8) {
         let addr2 = addr % 24;
         let mut halt = false;
@@ -454,12 +502,10 @@ impl NesApu {
                 }
                 if (data2 & 0x10) == 0 {
                     self.dmc.length = 0;
-                } else {
-                    if self.dmc.length == 0 {
-                        self.dmc.programmed_length = (self.registers[0x13] as u16) * 16 + 1;
-                        self.dmc.length = self.dmc.programmed_length;
-                        self.dmc.playing = true;
-                    }
+                } else if self.dmc.length == 0 {
+                    self.dmc.programmed_length = (self.registers[0x13] as u16) * 16 + 1;
+                    self.dmc.length = self.dmc.programmed_length;
+                    self.dmc.playing = true;
                 }
                 self.dmc.interrupt_flag = false;
                 self.registers[addr2 as usize] = data2;
@@ -484,7 +530,7 @@ impl NesApu {
         }
     }
 
-    //it is assumed that the only readable address is filtered before making it to this function
+    /// Read the apu register, it is assumed that the only readable address is filtered before making it to this function
     pub fn read(&mut self, _addr: u16) -> u8 {
         let mut data = self.registers[0x15] & 0x40;
         if self.dmc.interrupt_flag {
@@ -507,7 +553,6 @@ impl NesApu {
             data |= 1 << 4;
         }
         self.registers[0x15] &= !0x40;
-        self.read_count = self.read_count.wrapping_add(1);
         data
     }
 }
diff --git a/nes/rust/src/benchmark.rs b/nes/rust/src/benchmark.rs
index 0cdc17d..c4c89c0 100644
--- a/nes/rust/src/benchmark.rs
+++ b/nes/rust/src/benchmark.rs
@@ -1,14 +1,14 @@
 #![allow(dead_code)]
 
-pub mod apu;
-pub mod cartridge;
-pub mod controller;
-pub mod cpu;
-pub mod emulator_data;
-pub mod motherboard;
-pub mod ppu;
-pub mod romlist;
-pub mod utility;
+mod apu;
+mod cartridge;
+mod controller;
+mod cpu;
+mod emulator_data;
+mod motherboard;
+mod ppu;
+mod romlist;
+mod utility;
 
 use crate::apu::NesApu;
 use crate::cartridge::NesCartridge;
@@ -154,7 +154,7 @@ pub fn romlist_bench(c: &mut Criterion) {
         b.iter(|| {
             let _e = std::fs::remove_file("./roms.bin");
             let mut list = romlist::RomListParser::new();
-            list.find_roms("../roms");
+            list.find_roms("../test_roms");
             println!("There are {} roms", list.count());
             list.process_roms();
         });
@@ -163,7 +163,7 @@ pub fn romlist_bench(c: &mut Criterion) {
     group.bench_function("second run", |b| {
         b.iter(|| {
             let mut list = romlist::RomListParser::new();
-            list.find_roms("../roms");
+            list.find_roms("../test_roms");
             println!("There are {} roms", list.count());
             list.process_roms();
         });
diff --git a/nes/rust/src/cartridge.rs b/nes/rust/src/cartridge.rs
index 47a359e..a5ad597 100644
--- a/nes/rust/src/cartridge.rs
+++ b/nes/rust/src/cartridge.rs
@@ -1,3 +1,5 @@
+//! This module is responsible for cartridge related emulation, including mapper emulation.
+
 mod mapper00;
 mod mapper01;
 mod mapper03;
@@ -8,21 +10,29 @@ use mapper03::Mapper03;
 
 use serde::{Deserialize, Serialize};
 
+/// All mappers must implement this.
 #[enum_dispatch::enum_dispatch]
 trait NesMapperTrait {
+    /// Run a cpu memory read cycle
     fn memory_cycle_read(&mut self, cart: &mut NesCartridgeData, addr: u16) -> Option<u8>;
+    /// Run a cpu memory write cycle
     fn memory_cycle_write(&mut self, cart: &mut NesCartridgeData, addr: u16, data: u8);
+    /// Runs a memory cycle that does nothing, for mappers that need to do special things.
     fn memory_cycle_nop(&mut self);
     #[must_use]
-    //performs the first half of a ppu memory cycle
-    //returns A10 for internal VRAM and the motherboard CS line (for internal VRAM)
-    //A10 is straight forward, CS line is active low like the electronics would be
+    /// performs the first half of a ppu memory cycle
+    /// returns A10 for internal VRAM and the motherboard CS line (for internal VRAM)
+    /// A10 is straight forward, CS line is active low like the electronics would be
     fn ppu_memory_cycle_address(&mut self, addr: u16) -> (bool, bool);
+    /// Run a ppu read cycle
     fn ppu_memory_cycle_read(&mut self, cart: &mut NesCartridgeData) -> Option<u8>;
+    /// Run a ppu write cycle
     fn ppu_memory_cycle_write(&mut self, cart: &mut NesCartridgeData, data: u8);
+    /// Modify a byte for the cartridge rom
     fn rom_byte_hack(&mut self, cart: &mut NesCartridgeData, addr: u32, new_byte: u8);
 }
 
+/// The mapper for an nes cartridge
 #[non_exhaustive]
 #[enum_dispatch::enum_dispatch(NesMapperTrait)]
 #[derive(serde::Serialize, serde::Deserialize)]
@@ -31,58 +41,83 @@ pub enum NesMapper {
     Mapper01,
     Mapper03,
 }
+
+/// The trait for cpu memory reads and writes, implemented by devices on the bus
 pub trait NesMemoryBusDevice {
+    /// Run a cpu memory read cycle on the cartridge
     fn memory_cycle_read(
         &mut self,
         addr: u16,
         out: [bool; 3],
         controllers: [bool; 2],
     ) -> Option<u8>;
+    /// Run a cpu memory write cycle on the cartridge
     fn memory_cycle_write(&mut self, addr: u16, data: u8);
 }
 
+/// The data for a cartridge.
 #[non_exhaustive]
 #[derive(serde::Serialize, serde::Deserialize)]
 pub struct NesCartridgeData {
+    /// An optional trainer for the cartridge
     trainer: Option<Vec<u8>>,
+    /// The prg rom, where code typically goes.
     prg_rom: Vec<u8>,
+    /// The chr rom, where graphics are generally stored
     chr_rom: Vec<u8>,
+    /// chr_ram ?
     chr_ram: bool,
+    /// inst_rom ?
     inst_rom: Option<Vec<u8>>,
+    /// prom?
     prom: Option<(Vec<u8>, Vec<u8>)>,
+    /// Program ram
     prg_ram: Vec<u8>,
     /// True for vertical mirroring, false for horizontal mirroring
     mirroring: bool,
+    /// The mapper number
     mapper: u32,
 }
 
+/// A cartridge, including the mapper structure
 #[non_exhaustive]
 #[derive(serde::Serialize, serde::Deserialize)]
 pub struct NesCartridge {
+    /// The data in the cartridge, including ram and everything else
     data: NesCartridgeData,
+    /// The mapper
     mapper: NesMapper,
+    /// The mapper number
     mappernum: u32,
 }
 
+/// The types of errors that can occur when loading a rom
 #[derive(Serialize, Deserialize, Debug)]
 pub enum CartridgeError {
+    /// There can be a filesystem error opening the file
     FsError(String),
+    /// It might not be any known type of rom
     InvalidRom,
+    /// The rom might be incompatible (unparsed format)
     IncompatibleRom,
+    /// The rom might use a mapper that is not yet implemented
     IncompatibleMapper(u32),
+    /// The rom might be too short, indicating some bytes got cut off of the end, or that it has been corrupted/modified
     RomTooShort,
 }
 
 impl NesCartridge {
+    /// "Parses" an obsolete ines rom
     fn load_obsolete_ines(_rom_contents: &[u8]) -> Result<Self, CartridgeError> {
         Err(CartridgeError::IncompatibleRom)
     }
 
+    /// Builds a mapper for the rom
     fn get_mapper(mapper: u32, rom_data: &NesCartridgeData) -> Result<NesMapper, CartridgeError> {
         let mapper = match mapper {
-            0 => mapper00::Mapper00::new(&rom_data),
-            1 => mapper01::Mapper01::new(&rom_data),
-            3 => mapper03::Mapper03::new(&rom_data),
+            0 => mapper00::Mapper00::new(rom_data),
+            1 => mapper01::Mapper01::new(rom_data),
+            3 => mapper03::Mapper03::new(rom_data),
             _ => {
                 return Err(CartridgeError::IncompatibleMapper(mapper));
             }
@@ -90,10 +125,11 @@ impl NesCartridge {
         Ok(mapper)
     }
 
+    /// Parses an ines1 format rom
     fn load_ines1(rom_contents: &[u8]) -> Result<Self, CartridgeError> {
-        if rom_contents[0] != 'N' as u8
-            || rom_contents[1] != 'E' as u8
-            || rom_contents[2] != 'S' as u8
+        if rom_contents[0] != b'N'
+            || rom_contents[1] != b'E'
+            || rom_contents[2] != b'S'
             || rom_contents[3] != 0x1a
         {
             return Err(CartridgeError::InvalidRom);
@@ -104,7 +140,7 @@ impl NesCartridge {
         let chr_ram = chr_rom_size == 0;
         if chr_ram {
             //TODO determine correct size for chr-ram
-            chr_rom_size = 8192 * 1;
+            chr_rom_size = 8192;
         }
         let mut file_offset: usize = 16;
         let trainer = if (rom_contents[6] & 8) != 0 {
@@ -166,15 +202,15 @@ impl NesCartridge {
             prg_ram.push(v);
         }
 
-        let mappernum = (rom_contents[6] >> 4) as u8 | (rom_contents[7] & 0xf0) as u8;
+        let mappernum = (rom_contents[6] >> 4) | (rom_contents[7] & 0xf0);
         let rom_data = NesCartridgeData {
-            trainer: trainer,
-            prg_rom: prg_rom,
-            chr_rom: chr_rom,
-            chr_ram: chr_ram,
-            inst_rom: inst_rom,
+            trainer,
+            prg_rom,
+            chr_rom,
+            chr_ram,
+            inst_rom,
             prom: None,
-            prg_ram: prg_ram,
+            prg_ram,
             mirroring: (rom_contents[6] & 1) != 0,
             mapper: mappernum as u32,
         };
@@ -187,10 +223,11 @@ impl NesCartridge {
         })
     }
 
+    /// Parses an ines2 format rom
     fn load_ines2(rom_contents: &[u8]) -> Result<Self, CartridgeError> {
-        if rom_contents[0] != 'N' as u8
-            || rom_contents[1] != 'E' as u8
-            || rom_contents[2] != 'S' as u8
+        if rom_contents[0] != b'N'
+            || rom_contents[1] != b'E'
+            || rom_contents[2] != b'S'
             || rom_contents[3] != 0x1a
         {
             return Err(CartridgeError::InvalidRom);
@@ -255,9 +292,9 @@ impl NesCartridge {
             | (rom_contents[7] & 0xf0) as u16
             | (rom_contents[8] as u16) << 8;
         let rom_data = NesCartridgeData {
-            trainer: trainer,
-            prg_rom: prg_rom,
-            chr_rom: chr_rom,
+            trainer,
+            prg_rom,
+            chr_rom,
             chr_ram: false,
             inst_rom: None,
             prom: None,
@@ -270,11 +307,12 @@ impl NesCartridge {
 
         Ok(Self {
             data: rom_data,
-            mapper: mapper,
+            mapper,
             mappernum: mappernum as u32,
         })
     }
 
+    /// Load a cartridge, returning an error or the new cartridge
     pub fn load_cartridge(name: String) -> Result<Self, CartridgeError> {
         let rom_contents = std::fs::read(name);
         if let Err(e) = rom_contents {
@@ -284,53 +322,59 @@ impl NesCartridge {
         if rom_contents.len() < 16 {
             return Err(CartridgeError::InvalidRom);
         }
-        if rom_contents[0] != 'N' as u8
-            || rom_contents[1] != 'E' as u8
-            || rom_contents[2] != 'S' as u8
+        if rom_contents[0] != b'N'
+            || rom_contents[1] != b'E'
+            || rom_contents[2] != b'S'
             || rom_contents[3] != 0x1a
         {
             return Err(CartridgeError::InvalidRom);
         }
         if (rom_contents[7] & 0xC) == 8 {
-            return Self::load_ines2(&rom_contents);
+            Self::load_ines2(&rom_contents)
         } else if (rom_contents[7] & 0xC) == 4 {
-            return Self::load_obsolete_ines(&rom_contents);
+            Self::load_obsolete_ines(&rom_contents)
         } else if (rom_contents[7] & 0xC) == 0
             && rom_contents[12] == 0
             && rom_contents[13] == 0
             && rom_contents[14] == 0
             && rom_contents[15] == 0
         {
-            return Self::load_ines1(&rom_contents);
+            Self::load_ines1(&rom_contents)
         } else {
             //or ines 0.7
-            return Self::load_obsolete_ines(&rom_contents);
+            Self::load_obsolete_ines(&rom_contents)
         }
     }
 }
 
 impl NesCartridge {
+    /// Drive a cpu memory read cycle
     pub fn memory_read(&mut self, addr: u16) -> Option<u8> {
         self.mapper.memory_cycle_read(&mut self.data, addr)
     }
 
+    /// Drive a cpu memory write cycle
     pub fn memory_write(&mut self, addr: u16, data: u8) {
         self.mapper.memory_cycle_write(&mut self.data, addr, data);
     }
 
+    /// A nop for the cpu bus, for driving mapper logic that needs it.
     pub fn memory_nop(&mut self) {
         self.mapper.memory_cycle_nop();
     }
 
+    /// Run a ppu address cycle
     #[must_use]
     pub fn ppu_cycle_1(&mut self, addr: u16) -> (bool, bool) {
         self.mapper.ppu_memory_cycle_address(addr)
     }
 
+    /// Run a ppu write cyle
     pub fn ppu_cycle_write(&mut self, data: u8) {
         self.mapper.ppu_memory_cycle_write(&mut self.data, data);
     }
 
+    /// Run a ppu read cycle
     pub fn ppu_cycle_read(&mut self) -> u8 {
         if let Some(a) = self.mapper.ppu_memory_cycle_read(&mut self.data) {
             a
@@ -340,6 +384,7 @@ impl NesCartridge {
         }
     }
 
+    ///Used in testing to over-write the contents of a specific byte in the rom image
     #[cfg(test)]
     pub fn rom_byte_hack(&mut self, addr: u32, new_byte: u8) {
         self.mapper.rom_byte_hack(&mut self.data, addr, new_byte);
diff --git a/nes/rust/src/cartridge/mapper00.rs b/nes/rust/src/cartridge/mapper00.rs
index 774a47c..a9d673a 100644
--- a/nes/rust/src/cartridge/mapper00.rs
+++ b/nes/rust/src/cartridge/mapper00.rs
@@ -1,14 +1,20 @@
+//! Implements mapper00
+
 use crate::cartridge::NesCartridgeData;
 use crate::cartridge::{NesMapper, NesMapperTrait};
 
+/// Mapper00
 #[non_exhaustive]
 #[derive(serde::Serialize, serde::Deserialize)]
 pub struct Mapper00 {
+    /// True when mirroring is vertical
     mirror_vertical: bool,
+    /// The address for ppu memory cycles
     ppu_address: u16,
 }
 
 impl Mapper00 {
+    /// Create a new mapper00
     pub fn new(d: &NesCartridgeData) -> NesMapper {
         NesMapper::from(Self {
             mirror_vertical: d.mirroring,
@@ -22,8 +28,8 @@ impl NesMapperTrait for Mapper00 {
         match addr {
             0x6000..=0x7fff => {
                 let mut addr2 = addr & 0x1fff;
-                if cart.prg_ram.len() != 0 {
-                    addr2 = addr2 % cart.prg_ram.len() as u16;
+                if !cart.prg_ram.is_empty() {
+                    addr2 %= cart.prg_ram.len() as u16;
                     Some(cart.prg_ram[addr2 as usize])
                 } else {
                     None
@@ -53,14 +59,14 @@ impl NesMapperTrait for Mapper00 {
     }
 
     fn ppu_memory_cycle_read(&mut self, cart: &mut NesCartridgeData) -> Option<u8> {
-        if cart.chr_rom.len() == 0 {
+        if cart.chr_rom.is_empty() {
             return None;
         }
         Some(cart.chr_rom[(self.ppu_address as usize) % cart.chr_rom.len()])
     }
 
     fn ppu_memory_cycle_write(&mut self, cart: &mut NesCartridgeData, data: u8) {
-        if !cart.chr_ram || cart.chr_rom.len() == 0 {
+        if !cart.chr_ram || cart.chr_rom.is_empty() {
             return;
         }
         let addr2 = self.ppu_address as u32 % cart.chr_rom.len() as u32;
diff --git a/nes/rust/src/cartridge/mapper01.rs b/nes/rust/src/cartridge/mapper01.rs
index 36e1448..4c6fbce 100644
--- a/nes/rust/src/cartridge/mapper01.rs
+++ b/nes/rust/src/cartridge/mapper01.rs
@@ -1,18 +1,26 @@
+//! Implements mapper01
+
 use crate::cartridge::NesCartridgeData;
 use crate::cartridge::{NesMapper, NesMapperTrait};
 
+/// Mapper01
 #[non_exhaustive]
 #[derive(serde::Serialize, serde::Deserialize)]
 pub struct Mapper01 {
+    /// The conteents of the shift register
     shift_register: u8,
+    /// The counter used for inputting data into the shift register
     shift_counter: u8,
+    /// The shift register is locked
     shift_locked: bool,
     /// Control, chr bank 0, chr bank 1, prg bank
     registers: [u8; 4],
+    /// The ppu address for ppu cycles
     ppu_address: u16,
 }
 
 impl Mapper01 {
+    /// Create a new mapper01
     pub fn new(_d: &NesCartridgeData) -> NesMapper {
         NesMapper::from(Self {
             shift_register: 0,
@@ -23,6 +31,7 @@ impl Mapper01 {
         })
     }
 
+    /// Update a register in the mapper
     fn update_register(&mut self, adr: u8, data: u8) {
         self.registers[adr as usize] = data;
     }
@@ -34,8 +43,8 @@ impl NesMapperTrait for Mapper01 {
         match addr {
             0x6000..=0x7fff => {
                 let mut addr2 = addr & 0x1fff;
-                if cart.prg_ram.len() != 0 {
-                    addr2 = addr2 % cart.prg_ram.len() as u16;
+                if !cart.prg_ram.is_empty() {
+                    addr2 %= cart.prg_ram.len() as u16;
                     Some(cart.prg_ram[addr2 as usize])
                 } else {
                     None
@@ -47,7 +56,7 @@ impl NesMapperTrait for Mapper01 {
                         //32kb bankswitch
                         let addr2 = addr & 0x7fff;
                         let addr3 = addr2 as u32 % cart.prg_rom.len() as u32;
-                        let addr4 = ((self.registers[3] as u32 & 0xE) as u32) << 14;
+                        let addr4 = (self.registers[3] as u32 & 0xE) << 14;
                         let addr5 = addr3 | addr4;
                         Some(cart.prg_rom[addr5 as usize])
                     }
@@ -93,27 +102,23 @@ impl NesMapperTrait for Mapper01 {
     }
 
     fn memory_cycle_write(&mut self, _cart: &mut NesCartridgeData, addr: u16, data: u8) {
-        if addr >= 0x8000 {
-            if !self.shift_locked {
-                self.shift_locked = true;
-                if (data & 0x80) != 0 {
-                    self.shift_counter = 0;
-                    self.shift_register = 0;
-                    self.registers[0] |= 0xC0;
-                } else {
-                    if self.shift_counter < 5 {
-                        self.shift_counter += 1;
-                        self.shift_register >>= 1;
-                        if (data & 1) != 0 {
-                            self.shift_register |= 0x10;
-                        }
-                    } else {
-                        let adr_select = (addr & 0x6000) >> 13;
-                        self.update_register(adr_select as u8, self.shift_register);
-                        self.shift_counter = 0;
-                        self.shift_register = 0;
-                    }
+        if addr >= 0x8000 && !self.shift_locked {
+            self.shift_locked = true;
+            if (data & 0x80) != 0 {
+                self.shift_counter = 0;
+                self.shift_register = 0;
+                self.registers[0] |= 0xC0;
+            } else if self.shift_counter < 5 {
+                self.shift_counter += 1;
+                self.shift_register >>= 1;
+                if (data & 1) != 0 {
+                    self.shift_register |= 0x10;
                 }
+            } else {
+                let adr_select = (addr & 0x6000) >> 13;
+                self.update_register(adr_select as u8, self.shift_register);
+                self.shift_counter = 0;
+                self.shift_register = 0;
             }
         }
     }
@@ -130,7 +135,7 @@ impl NesMapperTrait for Mapper01 {
     }
 
     fn ppu_memory_cycle_read(&mut self, cart: &mut NesCartridgeData) -> Option<u8> {
-        if cart.chr_rom.len() == 0 {
+        if cart.chr_rom.is_empty() {
             return None;
         }
         if (self.registers[0] & 0x10) != 0 {
@@ -168,7 +173,7 @@ impl NesMapperTrait for Mapper01 {
         if !cart.chr_ram {
             return;
         }
-        if cart.chr_rom.len() == 0 {
+        if cart.chr_rom.is_empty() {
             return;
         }
         if (self.registers[0] & 0x10) != 0 {
@@ -190,14 +195,11 @@ impl NesMapperTrait for Mapper01 {
             }
         } else {
             //one 8kb bank
-            match self.ppu_address {
-                0..=0x1fff => {
-                    let addr2 = self.ppu_address & 0x1fff;
-                    let mut addr3 = addr2 as u32 % cart.chr_rom.len() as u32;
-                    addr3 |= (self.registers[1] as u32 & 0x1E) << 12;
-                    cart.chr_rom[addr3 as usize] = data;
-                }
-                _ => {}
+            if let 0..=0x1fff = self.ppu_address {
+                let addr2 = self.ppu_address & 0x1fff;
+                let mut addr3 = addr2 as u32 % cart.chr_rom.len() as u32;
+                addr3 |= (self.registers[1] as u32 & 0x1E) << 12;
+                cart.chr_rom[addr3 as usize] = data;
             }
         }
     }
diff --git a/nes/rust/src/cartridge/mapper03.rs b/nes/rust/src/cartridge/mapper03.rs
index db2ed4f..8cafb83 100644
--- a/nes/rust/src/cartridge/mapper03.rs
+++ b/nes/rust/src/cartridge/mapper03.rs
@@ -1,14 +1,20 @@
+//! Implements mapper 03
+
 use crate::cartridge::NesCartridgeData;
 use crate::cartridge::{NesMapper, NesMapperTrait};
 
+/// Mapper 03
 #[non_exhaustive]
 #[derive(serde::Serialize, serde::Deserialize)]
 pub struct Mapper03 {
+    /// Flag determining if mirroring is vertical
     mirror_vertical: bool,
+    /// The ppu address for ppu addressing
     ppu_address: u16,
 }
 
 impl Mapper03 {
+    /// Create a new mapper03
     pub fn new(d: &NesCartridgeData) -> NesMapper {
         NesMapper::from(Self {
             mirror_vertical: d.mirroring,
@@ -22,8 +28,8 @@ impl NesMapperTrait for Mapper03 {
         match addr {
             0x6000..=0x7fff => {
                 let mut addr2 = addr & 0x1fff;
-                if cart.prg_ram.len() != 0 {
-                    addr2 = addr2 % cart.prg_ram.len() as u16;
+                if !cart.prg_ram.is_empty() {
+                    addr2 %= cart.prg_ram.len() as u16;
                     Some(cart.prg_ram[addr2 as usize])
                 } else {
                     None
@@ -53,7 +59,7 @@ impl NesMapperTrait for Mapper03 {
     }
 
     fn ppu_memory_cycle_read(&mut self, cart: &mut NesCartridgeData) -> Option<u8> {
-        if cart.chr_rom.len() == 0 {
+        if cart.chr_rom.is_empty() {
             return None;
         }
         Some(cart.chr_rom[self.ppu_address as usize])
diff --git a/nes/rust/src/controller.rs b/nes/rust/src/controller.rs
index 44d9690..3d88145 100644
--- a/nes/rust/src/controller.rs
+++ b/nes/rust/src/controller.rs
@@ -1,16 +1,23 @@
+//! This module is responsible for emulating controllers for the nes system.
+
 #[cfg(feature = "eframe")]
 use eframe::egui;
 
 #[cfg(feature = "egui-multiwin")]
 use egui_multiwin::egui;
 
+/// The trait the all controllers must implement
 #[enum_dispatch::enum_dispatch]
 pub trait NesControllerTrait {
+    /// Update the latch bits on the controller
     fn update_latch_bits(&mut self, data: [bool; 3]);
+    /// Read data from the controller.
     fn read_data(&mut self) -> u8;
+    /// Provides an egui input state to update the controller state.
     fn provide_egui_ref(&mut self, data: &egui::InputState);
 }
 
+/// A generic implementation of a NES controller
 #[non_exhaustive]
 #[enum_dispatch::enum_dispatch(NesControllerTrait)]
 #[derive(serde::Serialize, serde::Deserialize)]
@@ -19,23 +26,36 @@ pub enum NesController {
     DummyController,
 }
 
+/// A standard nes controller implementation
 #[derive(serde::Serialize, serde::Deserialize)]
 pub struct StandardController {
+    /// The status of all 8 buttons
     controller_buttons: u8,
+    /// The contents of the shift register
     shift_register: u8,
+    /// The strobe signal triggers loading the controller data into the shift register
     strobe: bool,
 }
 
+/// Flag for the a button
 const BUTTON_A: u8 = 0x01;
+/// Flag for the b button
 const BUTTON_B: u8 = 0x02;
+/// Flag for the select button
 const BUTTON_SELECT: u8 = 0x04;
+/// Flag for the start button
 const BUTTON_START: u8 = 0x08;
+/// Flag for the up button
 const BUTTON_UP: u8 = 0x10;
+/// Flag for the down button
 const BUTTON_DOWN: u8 = 0x20;
+/// Flag for the left button
 const BUTTON_LEFT: u8 = 0x40;
+/// Flag for the right button
 const BUTTON_RIGHT: u8 = 0x80;
 
 impl StandardController {
+    /// Create a new controller
     pub fn new() -> NesController {
         (Self {
             controller_buttons: 0xff,
@@ -45,6 +65,7 @@ impl StandardController {
         .into()
     }
 
+    ///convenience function to check the strobe, to determine of the buttons should be loaded to the shift register
     fn check_strobe(&mut self) {
         if self.strobe {
             self.shift_register = self.controller_buttons;
@@ -60,7 +81,7 @@ impl NesControllerTrait for StandardController {
     fn read_data(&mut self) -> u8 {
         self.check_strobe();
         let data = self.shift_register & 1;
-        self.shift_register = (self.shift_register >> 1) | 0x00;
+        self.shift_register >>= 1;
         data | 0x1e
     }
     fn provide_egui_ref(&mut self, data: &egui::InputState) {
@@ -95,10 +116,12 @@ impl NesControllerTrait for StandardController {
     }
 }
 
+/// A do nothing controller
 #[derive(serde::Serialize, serde::Deserialize)]
 pub struct DummyController {}
 
 impl DummyController {
+    /// Create a new dummy controller
     pub fn new() -> NesController {
         NesController::from(Self {})
     }
diff --git a/nes/rust/src/cpu.rs b/nes/rust/src/cpu.rs
index 7dfc18e..fa464d3 100644
--- a/nes/rust/src/cpu.rs
+++ b/nes/rust/src/cpu.rs
@@ -1,93 +1,141 @@
+//! This module is responsible for emulating the cpu of the nes.
+
 use crate::apu::NesApu;
 use crate::motherboard::NesMotherboard;
 use crate::ppu::NesPpu;
 
+/// The peripherals for the cpu
 #[non_exhaustive]
 #[derive(serde::Serialize, serde::Deserialize)]
 pub struct NesCpuPeripherals {
+    /// The ppu for the nes system
     pub ppu: NesPpu,
+    /// The apu for the nes system
     pub apu: NesApu,
 }
 
 impl NesCpuPeripherals {
+    /// Create a new sett of cpu peripherals
     pub fn new(ppu: NesPpu, apu: NesApu) -> Self {
-        Self { ppu: ppu, apu: apu }
+        Self { ppu, apu }
     }
 
+    /// Run a ppu address cycle
     pub fn ppu_cycle(&mut self, bus: &mut NesMotherboard) {
         self.ppu.cycle(bus);
     }
 
+    /// Run a ppu read cycle
     pub fn ppu_read(&mut self, addr: u16) -> Option<u8> {
         self.ppu.read(addr)
     }
 
+    /// Run a ppu write cycle
     pub fn ppu_write(&mut self, addr: u16, data: u8) {
         self.ppu.write(addr, data);
     }
 
+    /// Returns true when the frame has ended. USed for synchronizing the emulator to the appropriate frame rate
     pub fn ppu_frame_end(&mut self) -> bool {
         self.ppu.get_frame_end()
     }
 
-    pub fn ppu_get_frame(&mut self) -> &Box<[u8; 256 * 240 * 3]> {
+    /// Returns a reference to the frame data for the ppu
+    pub fn ppu_get_frame(&mut self) -> &[u8; 256 * 240 * 3] {
         self.ppu.get_frame()
     }
 
+    /// Used for automated testing, to determine how many frames have passed.
     #[cfg(any(test, debug_assertions))]
     pub fn ppu_frame_number(&self) -> u64 {
         self.ppu.frame_number()
     }
 
+    /// Returns the ppu irq line
     pub fn ppu_irq(&self) -> bool {
         self.ppu.irq()
     }
 
+    /// Reset the ppu
     pub fn ppu_reset(&mut self) {
         self.ppu.reset();
     }
 }
 
+/// A struct for implementing the nes cpu
 #[non_exhaustive]
 #[derive(serde::Serialize, serde::Deserialize)]
 pub struct NesCpu {
+    /// The a register
     a: u8,
+    /// The x register
     x: u8,
+    /// The y register
     y: u8,
+    /// The stack register
     s: u8,
+    /// The flags register
     p: u8,
+    /// The program counter
     pc: u16,
+    /// The portion of an instruction currently being executed
     subcycle: u8,
+    /// Indicates that the reset routine of the cpu should execute
     reset: bool,
+    /// The current opcode being executed
     opcode: Option<u8>,
+    /// A temporary variable used inn proccessing instructions
     temp: u8,
+    /// A temporary variable used inn proccessing instructions
     temp2: u8,
+    /// A temporary address used in processing instructions
     tempaddr: u16,
+    /// A list of breakpoints for the cpu
     #[cfg(debug_assertions)]
     breakpoints: [Option<u16>; 10],
+    /// The string that corresponds to the disassembly for the most recently fetched instruction
     #[cfg(debug_assertions)]
     disassembly: String,
+    /// True when the last byte of an instruction has been fetched
     #[cfg(debug_assertions)]
     done_fetching: bool,
+    /// The status of nmi_detection from last cpu cycle
     prev_nmi: bool,
+    /// True when an nmi has been detected
     nmi_detected: bool,
+    /// Shift register for the interrupt detection routine
     interrupt_shift: [(bool, bool); 2],
+    /// Indicates the type of interrupt, true for nmi, false for irq
     interrupt_type: bool,
+    /// Indicates that the cpu is currently interrupting with an interrupt
     interrupting: bool,
+    /// The address to use for oam dam
     oamdma: Option<u8>,
+    /// The dma counter for oam dma
     dma_counter: u16,
+    /// The three outputs used for controller driving
     outs: [bool; 3],
+    /// The address for dmc dma
     dmc_dma: Option<u16>,
+    /// Counter for doing dmc dma operations, since it takes more than one cycle
     dmc_dma_counter: u8,
 }
 
+/// The carry flag for the cpu flags register
 const CPU_FLAG_CARRY: u8 = 1;
+/// The zero flag for the cpu flags register
 const CPU_FLAG_ZERO: u8 = 2;
+/// The interrupt disable flag for the cpu flags register
 const CPU_FLAG_INT_DISABLE: u8 = 4;
+/// The decimal flag for the cpu flags register
 const CPU_FLAG_DECIMAL: u8 = 8;
+/// The b1 flag for the cpu flags register
 const CPU_FLAG_B1: u8 = 0x10;
+/// The b2 flag for the cpu flags register
 const CPU_FLAG_B2: u8 = 0x20;
+/// The overflow flag for the cpu flags register
 const CPU_FLAG_OVERFLOW: u8 = 0x40;
+/// The negative flag for the cpu flags register
 const CPU_FLAG_NEGATIVE: u8 = 0x80;
 
 impl NesCpu {
@@ -125,46 +173,55 @@ impl NesCpu {
         }
     }
 
+    /// Returns true at the very start of an instruction
     #[cfg(test)]
     pub fn instruction_start(&self) -> bool {
         self.subcycle == 0
     }
 
+    /// Returns true when done fetching all bytes for an instruction.
     #[cfg(debug_assertions)]
     pub fn breakpoint_option(&self) -> bool {
         self.done_fetching
     }
 
+    /// Returns the pc value
     #[cfg(any(test, debug_assertions))]
     pub fn get_pc(&self) -> u16 {
         self.pc
     }
 
+    /// Returns the a value
     #[cfg(any(test, debug_assertions))]
     pub fn get_a(&self) -> u8 {
         self.a
     }
 
+    /// Returns the x value
     #[cfg(any(test, debug_assertions))]
     pub fn get_x(&self) -> u8 {
         self.x
     }
 
+    /// Returns the y value
     #[cfg(any(test, debug_assertions))]
     pub fn get_y(&self) -> u8 {
         self.y
     }
 
+    /// Returns the p value
     #[cfg(any(test, debug_assertions))]
     pub fn get_p(&self) -> u8 {
         self.p
     }
 
+    /// Returns the sp value
     #[cfg(any(test, debug_assertions))]
     pub fn get_sp(&self) -> u8 {
         self.s
     }
 
+    /// Reset the cpu
     pub fn reset(&mut self) {
         self.s -= 3;
         self.p |= CPU_FLAG_INT_DISABLE; //set IRQ disable flag
@@ -178,11 +235,13 @@ impl NesCpu {
         }
     }
 
+    /// signal the end of a cpu instruction
     fn end_instruction(&mut self) {
         self.subcycle = 0;
         self.opcode = None;
     }
 
+    /// run the sbc calculation
     fn cpu_sbc(&mut self, temp: u8) {
         let overflow;
         let olda = self.a;
@@ -206,6 +265,7 @@ impl NesCpu {
         }
     }
 
+    /// Run the adc calculation
     fn cpu_adc(&mut self, temp: u8) {
         let overflow;
         let olda = self.a;
@@ -229,10 +289,12 @@ impl NesCpu {
         }
     }
 
+    /// Calculate the two output enable outputs
     fn calc_oe(&mut self, addr: u16) -> [bool; 2] {
         [addr != 0x4016, addr != 0x4017]
     }
 
+    /// convenience function for running a read cycle on the bus
     fn memory_cycle_read(
         &mut self,
         addr: u16,
@@ -242,6 +304,7 @@ impl NesCpu {
         bus.memory_cycle_read(addr, self.outs, self.calc_oe(addr), cpu_peripherals)
     }
 
+    /// Convenience function for running a write cycle on the bus
     fn memory_cycle_write(
         &mut self,
         addr: u16,
@@ -259,22 +322,23 @@ impl NesCpu {
         bus.memory_cycle_write(addr, data, self.outs, [true; 2], cpu_peripherals);
     }
 
+    /// Check all breakpoints to see if a break needs to occur
     #[cfg(debug_assertions)]
     fn check_breakpoints(&mut self) {
-        for b in self.breakpoints {
-            if let Some(br) = b {
-                if self.pc == br {
-                    self.subcycle = 1;
-                }
+        for b in self.breakpoints.into_iter().flatten() {
+            if self.pc == b {
+                self.subcycle = 1;
             }
         }
     }
 
+    /// Show the disassembly of the current instruction
     #[cfg(debug_assertions)]
     pub fn disassemble(&self) -> Option<String> {
         Some(self.disassembly.to_owned())
     }
 
+    /// Set the dma input for dmc dma
     pub fn set_dma_input(&mut self, data: Option<u16>) {
         if data.is_some() && self.dmc_dma.is_none() {
             self.dmc_dma = data;
@@ -282,6 +346,7 @@ impl NesCpu {
         }
     }
 
+    /// Run a single cycle of the cpu
     pub fn cycle(
         &mut self,
         bus: &mut NesMotherboard,
@@ -337,257 +402,457 @@ impl NesCpu {
                     self.reset = false;
                 }
             }
-        } else {
-            if let Some(a) = self.dmc_dma {
-                match self.dmc_dma_counter {
+        } else if let Some(a) = self.dmc_dma {
+            match self.dmc_dma_counter {
+                0 => {
+                    self.dmc_dma_counter += 1;
+                }
+                1 => {
+                    self.dmc_dma_counter += 1;
+                }
+                2 => {
+                    self.dmc_dma_counter += 1;
+                }
+                _ => {
+                    let t = self.memory_cycle_read(a, bus, cpu_peripherals);
+                    cpu_peripherals.apu.provide_dma_response(t);
+                    self.dmc_dma = None;
+                    self.dmc_dma_counter = 0;
+                }
+            }
+        } else if self.opcode.is_none() {
+            if (self.interrupt_shift[0].0 && ((self.p & CPU_FLAG_INT_DISABLE) == 0))
+                || self.interrupt_shift[0].1
+                || self.interrupting
+            {
+                match self.subcycle {
                     0 => {
-                        self.dmc_dma_counter += 1;
+                        self.interrupting = true;
+                        self.memory_cycle_read(self.pc, bus, cpu_peripherals);
+                        self.subcycle += 1;
                     }
                     1 => {
-                        self.dmc_dma_counter += 1;
+                        self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle += 1;
                     }
                     2 => {
-                        self.dmc_dma_counter += 1;
+                        self.memory_cycle_write(
+                            self.s as u16 + 0x100,
+                            self.pc.to_le_bytes()[1],
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.s = self.s.wrapping_sub(1);
+                        self.subcycle += 1;
                     }
-                    _ => {
-                        let t = self.memory_cycle_read(a, bus, cpu_peripherals);
-                        cpu_peripherals.apu.provide_dma_response(t);
-                        self.dmc_dma = None;
-                        self.dmc_dma_counter = 0;
+                    3 => {
+                        self.memory_cycle_write(
+                            self.s as u16 + 0x100,
+                            self.pc.to_le_bytes()[0],
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.s = self.s.wrapping_sub(1);
+                        self.interrupt_type = self.nmi_detected;
+                        self.nmi_detected = false;
+                        self.subcycle += 1;
                     }
-                }
-            } else if let None = self.opcode {
-                if (self.interrupt_shift[0].0 && ((self.p & CPU_FLAG_INT_DISABLE) == 0))
-                    || self.interrupt_shift[0].1
-                    || self.interrupting
-                {
-                    match self.subcycle {
-                        0 => {
-                            self.interrupting = true;
-                            self.memory_cycle_read(self.pc, bus, cpu_peripherals);
-                            self.subcycle += 1;
-                        }
-                        1 => {
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle += 1;
-                        }
-                        2 => {
-                            self.memory_cycle_write(
-                                self.s as u16 + 0x100,
-                                self.pc.to_le_bytes()[1],
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.s = self.s.wrapping_sub(1);
-                            self.subcycle += 1;
-                        }
-                        3 => {
-                            self.memory_cycle_write(
-                                self.s as u16 + 0x100,
-                                self.pc.to_le_bytes()[0],
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.s = self.s.wrapping_sub(1);
-                            self.interrupt_type = self.nmi_detected;
-                            self.nmi_detected = false;
-                            self.subcycle += 1;
-                        }
-                        4 => {
-                            self.p &= !(CPU_FLAG_B1 | CPU_FLAG_B2);
-                            self.memory_cycle_write(
-                                self.s as u16 + 0x100,
-                                self.p,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.s = self.s.wrapping_sub(1);
-                            self.subcycle += 1;
-                        }
-                        5 => {
-                            let addr = if !self.interrupt_type {
-                                //IRQ
-                                0xfffe
+                    4 => {
+                        self.p &= !(CPU_FLAG_B1 | CPU_FLAG_B2);
+                        self.memory_cycle_write(
+                            self.s as u16 + 0x100,
+                            self.p,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.s = self.s.wrapping_sub(1);
+                        self.subcycle += 1;
+                    }
+                    5 => {
+                        let addr = if !self.interrupt_type {
+                            //IRQ
+                            0xfffe
+                        } else {
+                            //NMI
+                            0xfffa
+                        };
+                        #[cfg(debug_assertions)]
+                        {
+                            if !self.interrupt_type {
+                                self.disassembly = "IRQ".to_string();
                             } else {
-                                //NMI
-                                0xfffa
-                            };
-                            #[cfg(debug_assertions)]
-                            {
-                                if !self.interrupt_type {
-                                    self.disassembly = format!("IRQ");
-                                } else {
-                                    self.disassembly = format!("NMI");
-                                }
-                                self.done_fetching = true;
+                                self.disassembly = "NMI".to_string();
                             }
-                            let pcl = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            let mut pc = self.pc.to_le_bytes();
-                            pc[0] = pcl;
-                            self.pc = u16::from_le_bytes(pc);
-                            self.p |= CPU_FLAG_INT_DISABLE;
-                            self.subcycle += 1;
-                        }
-                        _ => {
-                            let addr = if !self.interrupt_type {
-                                //IRQ
-                                0xffff
-                            } else {
-                                //NMI
-                                0xfffb
-                            };
-                            let pch = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            let mut pc = self.pc.to_le_bytes();
-                            pc[1] = pch;
-                            self.pc = u16::from_le_bytes(pc);
-                            self.subcycle = 0;
-                            self.interrupting = false;
-                        }
-                    }
-                } else if let Some(addr) = self.oamdma {
-                    if self.dma_counter == 512 {
-                        self.oamdma = None;
-                        self.dma_counter = 0;
-                    } else if (self.dma_counter & 1) == 0 {
-                        let addr = (addr as u16) << 8 | (self.dma_counter >> 1);
-                        self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                        self.dma_counter += 1;
-                    } else {
-                        self.memory_cycle_write(0x2004, self.temp, bus, cpu_peripherals);
-                        self.dma_counter += 1;
+                            self.done_fetching = true;
+                        }
+                        let pcl = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        let mut pc = self.pc.to_le_bytes();
+                        pc[0] = pcl;
+                        self.pc = u16::from_le_bytes(pc);
+                        self.p |= CPU_FLAG_INT_DISABLE;
+                        self.subcycle += 1;
+                    }
+                    _ => {
+                        let addr = if !self.interrupt_type {
+                            //IRQ
+                            0xffff
+                        } else {
+                            //NMI
+                            0xfffb
+                        };
+                        let pch = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        let mut pc = self.pc.to_le_bytes();
+                        pc[1] = pch;
+                        self.pc = u16::from_le_bytes(pc);
+                        self.subcycle = 0;
+                        self.interrupting = false;
                     }
+                }
+            } else if let Some(addr) = self.oamdma {
+                if self.dma_counter == 512 {
+                    self.oamdma = None;
+                    self.dma_counter = 0;
+                } else if (self.dma_counter & 1) == 0 {
+                    let addr = (addr as u16) << 8 | (self.dma_counter >> 1);
+                    self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                    self.dma_counter += 1;
                 } else {
-                    self.opcode = Some(self.memory_cycle_read(self.pc, bus, cpu_peripherals));
+                    self.memory_cycle_write(0x2004, self.temp, bus, cpu_peripherals);
+                    self.dma_counter += 1;
+                }
+            } else {
+                self.opcode = Some(self.memory_cycle_read(self.pc, bus, cpu_peripherals));
+                #[cfg(debug_assertions)]
+                self.check_breakpoints();
+                self.subcycle = 1;
+            }
+        } else if let Some(o) = self.opcode {
+            match o {
+                //brk instruction
+                0 => match self.subcycle {
+                    1 => {
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = "BRK".to_string();
+                            self.done_fetching = true;
+                        }
+                        self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        let pc = self.pc.to_le_bytes();
+                        self.memory_cycle_write(0x100 + self.s as u16, pc[1], bus, cpu_peripherals);
+                        self.s = self.s.wrapping_sub(1);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let pc = self.pc.to_le_bytes();
+                        self.memory_cycle_write(0x100 + self.s as u16, pc[0], bus, cpu_peripherals);
+                        self.s = self.s.wrapping_sub(1);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.p |= CPU_FLAG_B1;
+                        self.memory_cycle_write(
+                            0x100 + self.s as u16,
+                            self.p,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.s = self.s.wrapping_sub(1);
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.temp = self.memory_cycle_read(0xfffe, bus, cpu_peripherals);
+                        self.p |= CPU_FLAG_INT_DISABLE;
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.temp2 = self.memory_cycle_read(0xffff, bus, cpu_peripherals);
+                        let addr: u16 = (self.temp as u16) | (self.temp2 as u16) << 8;
+                        self.pc = addr;
+                        self.end_instruction();
+                    }
+                },
+                //and immediate
+                0x29 => {
+                    self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
                     #[cfg(debug_assertions)]
-                    self.check_breakpoints();
-                    self.subcycle = 1;
+                    {
+                        self.disassembly = format!("AND #${:02x}", self.temp);
+                        self.done_fetching = true;
+                    }
+                    self.a &= self.temp;
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if self.a == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    if (self.a & self.temp & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    self.pc = self.pc.wrapping_add(2);
+                    self.end_instruction();
                 }
-            } else if let Some(o) = self.opcode {
-                match o {
-                    //brk instruction
-                    0 => match self.subcycle {
-                        1 => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = "BRK".to_string();
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                //and zero page
+                0x25 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("AND ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            let pc = self.pc.to_le_bytes();
-                            self.memory_cycle_write(
-                                0x100 + self.s as u16,
-                                pc[1],
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.s = self.s.wrapping_sub(1);
-                            self.subcycle = 3;
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.a &= self.temp;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        3 => {
-                            let pc = self.pc.to_le_bytes();
-                            self.memory_cycle_write(
-                                0x100 + self.s as u16,
-                                pc[0],
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.s = self.s.wrapping_sub(1);
-                            self.subcycle = 4;
+                        if (self.a & self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        4 => {
-                            self.p |= CPU_FLAG_B1;
-                            self.memory_cycle_write(
-                                0x100 + self.s as u16,
-                                self.p,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.s = self.s.wrapping_sub(1);
-                            self.subcycle = 5;
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //and zero page x
+                0x35 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("AND ${:02x},X", self.temp);
+                            self.done_fetching = true;
                         }
-                        5 => {
-                            self.temp = self.memory_cycle_read(0xfffe, bus, cpu_peripherals);
-                            self.p |= CPU_FLAG_INT_DISABLE;
-                            self.subcycle = 6;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(self.x) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.a &= self.temp;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //and absolute
+                0x2d => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("AND ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.temp2 = self.memory_cycle_read(0xffff, bus, cpu_peripherals);
-                            let addr: u16 = (self.temp as u16) | (self.temp2 as u16) << 8;
-                            self.pc = addr;
-                            self.end_instruction();
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
+                        self.a &= self.temp;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.a & self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //and absolute x
+                0x3d => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("AND ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //and immediate
-                    0x29 => match self.subcycle {
-                        _ => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("AND #${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.a = self.a & self.temp;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.x);
+                        if !overflow {
+                            addr = addr.wrapping_add(self.x as u16);
+                            self.a &= self.memory_cycle_read(addr, bus, cpu_peripherals);
                             self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
                             if self.a == 0 {
                                 self.p |= CPU_FLAG_ZERO;
                             }
-                            if (self.a & self.temp & 0x80) != 0 {
+                            if (self.a & 0x80) != 0 {
                                 self.p |= CPU_FLAG_NEGATIVE;
                             }
-                            self.pc = self.pc.wrapping_add(2);
+                            self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 4;
                         }
-                    },
-                    //and zero page
-                    0x25 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("AND ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.x as u16);
+                        self.a &= self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //and absolute y
+                0x39 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("AND ${:04x},Y", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.a = self.a & self.temp;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.y);
+                        if !overflow {
+                            addr = addr.wrapping_add(self.y as u16);
+                            self.a &= self.memory_cycle_read(addr, bus, cpu_peripherals);
                             self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
                             if self.a == 0 {
                                 self.p |= CPU_FLAG_ZERO;
                             }
-                            if (self.a & self.temp & 0x80) != 0 {
+                            if (self.a & 0x80) != 0 {
                                 self.p |= CPU_FLAG_NEGATIVE;
                             }
-                            self.pc = self.pc.wrapping_add(2);
+                            self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 4;
                         }
-                    },
-                    //and zero page x
-                    0x35 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("AND ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.a &= self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.subcycle = 3;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //and indirect x
+                0x21 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("AND (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(self.x) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.a &= self.temp;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.a &= self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //and indirect y
+                0x31 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("AND (${:02x}),Y", self.temp);
+                            self.done_fetching = true;
+                        }
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        let (_val, overflow) = self.temp2.overflowing_add(self.y);
+                        if !overflow {
+                            addr = addr.wrapping_add(self.y as u16);
+                            self.a &= self.memory_cycle_read(addr, bus, cpu_peripherals);
                             self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
                             if self.a == 0 {
                                 self.p |= CPU_FLAG_ZERO;
@@ -595,81 +860,158 @@ impl NesCpu {
                             if (self.a & 0x80) != 0 {
                                 self.p |= CPU_FLAG_NEGATIVE;
                             }
+
                             self.pc = self.pc.wrapping_add(2);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 5;
                         }
-                    },
-                    //and absolute
-                    0x2d => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                    }
+                    _ => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.a &= self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("AND ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
-                            self.a = self.a & self.temp;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //ora or immediate
+                0x09 => {
+                    self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = format!("ORA #${:02x}", self.temp);
+                        self.done_fetching = true;
+                    }
+                    self.a |= self.temp;
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if self.a == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    if (self.a & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    self.pc = self.pc.wrapping_add(2);
+                    self.end_instruction();
+                }
+                //ora zero page
+                0x05 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("ORA ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //and absolute x
-                    0x3d => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.subcycle = 2;
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.a |= self.temp;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("AND ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.x);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.x as u16);
-                                self.a =
-                                    self.a & self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.a == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.a & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //ora zero page x
+                0x15 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("ORA ${:02x},X", self.temp);
+                            self.done_fetching = true;
+                        }
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(self.x) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.a |= self.temp;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //ora absolute
+                0x0d => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("ORA ${:04x}", temp);
+                            self.done_fetching = true;
+                        }
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
+                        self.a |= self.temp;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //ora absolute x
+                0x1d => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("ORA ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.x);
+                        if !overflow {
                             addr = addr.wrapping_add(self.x as u16);
-                            self.a = self.a & self.memory_cycle_read(addr, bus, cpu_peripherals);
+                            self.a |= self.memory_cycle_read(addr, bus, cpu_peripherals);
                             self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
                             if self.a == 0 {
                                 self.p |= CPU_FLAG_ZERO;
@@ -677,51 +1019,50 @@ impl NesCpu {
                             if (self.a & 0x80) != 0 {
                                 self.p |= CPU_FLAG_NEGATIVE;
                             }
-
                             self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 4;
                         }
-                    },
-                    //and absolute y
-                    0x39 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.x as u16);
+                        self.a |= self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("AND ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.y);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.y as u16);
-                                self.a =
-                                    self.a & self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.a == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.a & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
+
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //ora absolute y
+                0x19 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("ORA ${:04x},Y", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.y);
+                        if !overflow {
                             addr = addr.wrapping_add(self.y as u16);
-                            self.a = self.a & self.memory_cycle_read(addr, bus, cpu_peripherals);
+                            self.a |= self.memory_cycle_read(addr, bus, cpu_peripherals);
                             self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
                             if self.a == 0 {
                                 self.p |= CPU_FLAG_ZERO;
@@ -729,42 +1070,98 @@ impl NesCpu {
                             if (self.a & 0x80) != 0 {
                                 self.p |= CPU_FLAG_NEGATIVE;
                             }
-
                             self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 4;
                         }
-                    },
-                    //and indirect x
-                    0x21 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("AND (${:02x},X)", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.a |= self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //ora indirect x
+                0x01 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("ORA (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                        4 => {
-                            let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            self.a = self.a & self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.subcycle = 5;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.a |= self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //ora indirect y
+                0x11 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("ORA (${:02x}),Y", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        let (_val, overflow) = self.temp2.overflowing_add(self.y);
+                        if !overflow {
+                            addr = addr.wrapping_add(self.y as u16);
+                            self.a |= self.memory_cycle_read(addr, bus, cpu_peripherals);
                             self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
                             if self.a == 0 {
                                 self.p |= CPU_FLAG_ZERO;
@@ -772,59 +1169,158 @@ impl NesCpu {
                             if (self.a & 0x80) != 0 {
                                 self.p |= CPU_FLAG_NEGATIVE;
                             }
+
                             self.pc = self.pc.wrapping_add(2);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 5;
                         }
-                    },
-                    //and indirect y
-                    0x31 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("AND (${:02x}),Y", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                    }
+                    _ => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.a |= self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        4 => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            let (_val, overflow) = self.temp2.overflowing_add(self.y);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.y as u16);
-                                self.a =
-                                    self.a & self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.a == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.a & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
 
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 5;
-                            }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //eor xor immediate
+                0x49 => {
+                    self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = format!("EOR #${:02x}", self.temp);
+                        self.done_fetching = true;
+                    }
+                    self.a ^= self.temp;
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if self.a == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    if (self.a & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    self.pc = self.pc.wrapping_add(2);
+                    self.end_instruction();
+                }
+                //eor zero page
+                0x45 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("EOR ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            addr = addr.wrapping_add(self.y as u16);
-                            self.a = self.a & self.memory_cycle_read(addr, bus, cpu_peripherals);
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.a ^= self.temp;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //eor zero page x
+                0x55 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("EOR ${:02x},X", self.temp);
+                            self.done_fetching = true;
+                        }
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(self.x) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.a ^= self.temp;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //eor absolute
+                0x4d => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("EOR ${:04x}", temp);
+                            self.done_fetching = true;
+                        }
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
+                        self.a ^= self.temp;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //eor absolute x
+                0x5d => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("EOR ${:04x},X", temp);
+                            self.done_fetching = true;
+                        }
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.x);
+                        if !overflow {
+                            addr = addr.wrapping_add(self.x as u16);
+                            self.a ^= self.memory_cycle_read(addr, bus, cpu_peripherals);
                             self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
                             if self.a == 0 {
                                 self.p |= CPU_FLAG_ZERO;
@@ -832,110 +1328,50 @@ impl NesCpu {
                             if (self.a & 0x80) != 0 {
                                 self.p |= CPU_FLAG_NEGATIVE;
                             }
-
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //ora or immediate
-                    0x09 => match self.subcycle {
-                        _ => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ORA #${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.a = self.a | self.temp;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //ora zero page
-                    0x05 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ORA ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        _ => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.a |= self.temp;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //ora zero page x
-                    0x15 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ORA ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.subcycle = 3;
-                        }
-                        _ => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(self.x) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.a |= self.temp;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
+                            self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 4;
                         }
-                    },
-                    //ora absolute
-                    0x0d => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.x as u16);
+                        self.a ^= self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("ORA ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
+
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //eor absolute y
+                0x59 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
                             let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
-                            self.a |= self.temp;
+                            self.disassembly = format!("EOR ${:04x},Y", temp);
+                            self.done_fetching = true;
+                        }
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.y);
+                        if !overflow {
+                            addr = addr.wrapping_add(self.y as u16);
+                            self.a ^= self.memory_cycle_read(addr, bus, cpu_peripherals);
                             self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
                             if self.a == 0 {
                                 self.p |= CPU_FLAG_ZERO;
@@ -945,100 +1381,96 @@ impl NesCpu {
                             }
                             self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 4;
                         }
-                    },
-                    //ora absolute x
-                    0x1d => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("ORA ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.a ^= self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        3 => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.x);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.x as u16);
-                                self.a =
-                                    self.a | self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.a == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.a & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            addr = addr.wrapping_add(self.x as u16);
-                            self.a = self.a | self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
 
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //eor xor indirect x
+                0x41 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("EOR (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //ora absolute y
-                    0x19 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.a ^= self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("ORA ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.y);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.y as u16);
-                                self.a =
-                                    self.a | self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.a == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.a & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //eor indirect y
+                0x51 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("EOR (${:02x}),Y", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        let (_val, overflow) = self.temp2.overflowing_add(self.y);
+                        if !overflow {
                             addr = addr.wrapping_add(self.y as u16);
-                            self.a = self.a | self.memory_cycle_read(addr, bus, cpu_peripherals);
+                            self.a ^= self.memory_cycle_read(addr, bus, cpu_peripherals);
                             self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
                             if self.a == 0 {
                                 self.p |= CPU_FLAG_ZERO;
@@ -1047,5622 +1479,4150 @@ impl NesCpu {
                                 self.p |= CPU_FLAG_NEGATIVE;
                             }
 
-                            self.pc = self.pc.wrapping_add(3);
+                            self.pc = self.pc.wrapping_add(2);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 5;
                         }
-                    },
-                    //ora indirect x
-                    0x01 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ORA (${:02x},X)", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                    }
+                    _ => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.a ^= self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        4 => {
-                            let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            self.a = self.a | self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.subcycle = 5;
+
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //adc immediate, add with carry
+                0x69 => {
+                    self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = format!("ADC #${:02x}", self.temp);
+                        self.done_fetching = true;
+                    }
+                    self.cpu_adc(self.temp);
+                    self.pc = self.pc.wrapping_add(2);
+                    self.end_instruction();
+                }
+                //adc zero page
+                0x65 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("ADC ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.cpu_adc(self.temp);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //adc zero page x
+                0x75 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("ADC ${:02x},X", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //ora indirect y
-                    0x11 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ORA (${:02x}),Y", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(self.x) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.cpu_adc(self.temp);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //adc absolute
+                0x6d => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("ADC ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
+                        self.cpu_adc(self.temp);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //adc absolute x
+                0x7d => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("ADC ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.x);
+                        if !overflow {
+                            addr = addr.wrapping_add(self.x as u16);
+                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                            self.cpu_adc(self.temp);
+                            self.pc = self.pc.wrapping_add(3);
+                            self.end_instruction();
+                        } else {
                             self.subcycle = 4;
                         }
-                        4 => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            let (_val, overflow) = self.temp2.overflowing_add(self.y);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.y as u16);
-                                self.a =
-                                    self.a | self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.a == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.a & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.x as u16);
+                        self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.cpu_adc(self.temp);
 
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 5;
-                            }
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //adc absolute y
+                0x79 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("ADC ${:04x},Y", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.y);
+                        if !overflow {
                             addr = addr.wrapping_add(self.y as u16);
-                            self.a = self.a | self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-
-                            self.pc = self.pc.wrapping_add(2);
+                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                            self.cpu_adc(self.temp);
+                            self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 4;
                         }
-                    },
-                    //eor xor immediate
-                    0x49 => match self.subcycle {
-                        _ => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("EOR #${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.a = self.a ^ self.temp;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.cpu_adc(self.temp);
+
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //adc adc indirect x
+                0x61 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("ADC (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //eor zero page
-                    0x45 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("EOR ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.cpu_adc(self.temp);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //adc indirect y
+                0x71 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("ADC (${:02x}),Y", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.a = self.a ^ self.temp;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        let (_val, overflow) = self.temp2.overflowing_add(self.y);
+                        if !overflow {
+                            addr = addr.wrapping_add(self.y as u16);
+                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                            self.cpu_adc(self.temp);
                             self.pc = self.pc.wrapping_add(2);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 5;
                         }
-                    },
-                    //eor zero page x
-                    0x55 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("EOR ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.subcycle = 3;
-                        }
-                        _ => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(self.x) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.a ^= self.temp;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                    }
+                    _ => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.cpu_adc(self.temp);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //sbc immediate, subtract with carry
+                0xe9 | 0xeb => {
+                    self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = format!("SBC #${:02x}", self.temp);
+                        self.done_fetching = true;
+                    }
+                    self.cpu_sbc(self.temp);
+                    self.pc = self.pc.wrapping_add(2);
+                    self.end_instruction();
+                }
+                //sbc zero page
+                0xe5 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("SBC ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //eor absolute
-                    0x4d => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.cpu_sbc(self.temp);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //sbc zero page x
+                0xf5 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("SBC ${:02x},X", self.temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("EOR ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(self.x) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.cpu_sbc(self.temp);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //sbc absolute
+                0xed => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("SBC ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
+                        self.cpu_sbc(self.temp);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //sbc absolute x
+                0xfd => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
                             let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
-                            self.a = self.a ^ self.temp;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //eor absolute x
-                    0x5d => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("EOR ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.x);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.x as u16);
-                                self.a =
-                                    self.a ^ self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.a == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.a & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
+                            self.disassembly = format!("SBC ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.x);
+                        if !overflow {
                             addr = addr.wrapping_add(self.x as u16);
-                            self.a = self.a ^ self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-
+                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                            self.cpu_sbc(self.temp);
                             self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 4;
                         }
-                    },
-                    //eor absolute y
-                    0x59 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("EOR ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.y);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.y as u16);
-                                self.a =
-                                    self.a ^ self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.a == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.a & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.x as u16);
+                        self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.cpu_sbc(self.temp);
+
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //sbc absolute y
+                0xf9 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("SBC ${:04x},Y", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.y);
+                        if !overflow {
                             addr = addr.wrapping_add(self.y as u16);
-                            self.a = self.a ^ self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-
+                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                            self.cpu_sbc(self.temp);
                             self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
-                        }
-                    },
-                    //eor xor indirect x
-                    0x41 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("EOR (${:02x},X)", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            self.a = self.a ^ self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //eor indirect y
-                    0x51 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("EOR (${:02x}),Y", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
+                        } else {
                             self.subcycle = 4;
                         }
-                        4 => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            let (_val, overflow) = self.temp2.overflowing_add(self.y);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.y as u16);
-                                self.a =
-                                    self.a ^ self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.a == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.a & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
-
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 5;
-                            }
-                        }
-                        _ => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            addr = addr.wrapping_add(self.y as u16);
-                            self.a = self.a ^ self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.cpu_sbc(self.temp);
 
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //adc immediate, add with carry
-                    0x69 => match self.subcycle {
-                        _ => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ADC #${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.cpu_adc(self.temp);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //sbc indirect x
+                0xe1 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("SBC (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //adc zero page
-                    0x65 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ADC ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.cpu_sbc(self.temp);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //sbc indirect y
+                0xf1 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("SBC (${:02x}),Y", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.cpu_adc(self.temp);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        let (_val, overflow) = self.temp2.overflowing_add(self.y);
+                        if !overflow {
+                            addr = addr.wrapping_add(self.y as u16);
+                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                            self.cpu_sbc(self.temp);
                             self.pc = self.pc.wrapping_add(2);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 5;
                         }
-                    },
-                    //adc zero page x
-                    0x75 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ADC ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
+                    }
+                    _ => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.cpu_sbc(self.temp);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //inc increment zero page
+                0xe6 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("INC ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.subcycle = 3;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp2 = self.temp2.wrapping_add(1);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.temp2 == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        _ => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(self.x) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.cpu_adc(self.temp);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                    },
-                    //adc absolute
-                    0x6d => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.memory_cycle_write(self.temp as u16, self.temp2, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //inc increment zero page x
+                0xf6 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("INC ${:02x},X", self.temp);
+                            self.done_fetching = true;
+                        }
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp2 = self.temp2.wrapping_add(1);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.temp2 == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("ADC ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
+                        self.memory_cycle_write(self.temp as u16, self.temp2, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //inc absolute
+                0xee => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
                             let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
-                            self.cpu_adc(self.temp);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //adc absolute x
-                    0x7d => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                            self.disassembly = format!("INC ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("ADC ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.temp = self.temp.wrapping_add(1);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.temp == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        3 => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.x);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.x as u16);
-                                self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.cpu_adc(self.temp);
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            addr = addr.wrapping_add(self.x as u16);
-                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.cpu_adc(self.temp);
-
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //inc absolute x
+                0xfe => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("INC ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //adc absolute y
-                    0x79 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.temp = self.temp.wrapping_add(1);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.temp == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("ADC ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.y);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.y as u16);
-                                self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.cpu_adc(self.temp);
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //iny, increment y
+                0xc8 => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "INY".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.y = self.y.wrapping_add(1);
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if (self.y & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    if self.y == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //inx, increment x
+                0xe8 => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "INX".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.x = self.x.wrapping_add(1);
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if (self.x & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    if self.x == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //dec decrement zero page
+                0xc6 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("DEC ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            addr = addr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.cpu_adc(self.temp);
-
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp2 = self.temp2.wrapping_sub(1);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.temp2 == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                    },
-                    //adc adc indirect x
-                    0x61 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ADC (${:02x},X)", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        2 => {
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.memory_cycle_write(self.temp as u16, self.temp2, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //dec decrement zero page x
+                0xd6 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("DEC ${:02x},X", self.temp);
+                            self.done_fetching = true;
+                        }
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp2 = self.temp2.wrapping_sub(1);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.temp2 == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        4 => {
-                            let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.subcycle = 5;
+                        self.memory_cycle_write(self.temp as u16, self.temp2, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //dec absolute
+                0xce => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("DEC ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.cpu_adc(self.temp);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.temp = self.temp.wrapping_sub(1);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.temp == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                    },
-                    //adc indirect y
-                    0x71 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ADC (${:02x}),Y", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //dec absolute x
+                0xde => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("DEC ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.temp = self.temp.wrapping_sub(1);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.temp == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        4 => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            let (_val, overflow) = self.temp2.overflowing_add(self.y);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.y as u16);
-                                self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.cpu_adc(self.temp);
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 5;
-                            }
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            addr = addr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.cpu_adc(self.temp);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //dey, decrement y
+                0x88 => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "DEY".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.y = self.y.wrapping_sub(1);
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if (self.y & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    if self.y == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //dex, decrement x
+                0xca => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "DEX".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.x = self.x.wrapping_sub(1);
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if (self.x & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    if self.x == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //tay, transfer accumulator to y
+                0xa8 => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "TAY".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.y = self.a;
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if (self.y & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    if self.y == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //tax, transfer accumulator to x
+                0xaa => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "TAX".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.x = self.a;
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if (self.x & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    if self.x == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //tya, transfer y to accumulator
+                0x98 => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "TYA".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.a = self.y;
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if (self.a & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    if self.a == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //txa, transfer x to accumulator
+                0x8a => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "TXA".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.a = self.x;
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if (self.a & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    if self.a == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //tsx, transfer stack pointer to x
+                0xba => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "TSX".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.x = self.s;
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if (self.x & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    if self.x == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //txs, transfer x to stack pointer
+                0x9a => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "TXS".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.s = self.x;
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //bit zero page
+                0x24 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("BIT ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //sbc immediate, subtract with carry
-                    0xe9 | 0xeb => match self.subcycle {
-                        _ => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("SBC #${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.cpu_sbc(self.temp);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.subcycle = 2;
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_OVERFLOW | CPU_FLAG_NEGATIVE);
+                        self.p |= self.temp & (CPU_FLAG_OVERFLOW | CPU_FLAG_NEGATIVE);
+                        self.temp &= self.a;
+                        self.p &= !CPU_FLAG_ZERO;
+                        if self.temp == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //bit absolute
+                0x2c => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("BIT ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //sbc zero page
-                    0xe5 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("SBC ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_OVERFLOW | CPU_FLAG_NEGATIVE);
+                        self.p |= self.temp & (CPU_FLAG_OVERFLOW | CPU_FLAG_NEGATIVE);
+                        self.temp &= self.a;
+                        self.p &= !CPU_FLAG_ZERO;
+                        if self.temp == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //cmp, compare immediate
+                0xc9 => {
+                    self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = format!("CMP #${:02x}", self.temp);
+                        self.done_fetching = true;
+                    }
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                    if self.a == self.temp {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    if self.a >= self.temp {
+                        self.p |= CPU_FLAG_CARRY;
+                    }
+                    if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    self.pc = self.pc.wrapping_add(2);
+                    self.end_instruction();
+                }
+                //cmp zero page
+                0xc5 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("CMP ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.cpu_sbc(self.temp);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.a == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                    },
-                    //sbc zero page x
-                    0xf5 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("SBC ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
+                        if self.a >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        2 => {
-                            self.subcycle = 3;
+                        if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(self.x) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.cpu_sbc(self.temp);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //cmp zero page x
+                0xd5 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("CMP ${:02x},X", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //sbc absolute
-                    0xed => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(self.x) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.a == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if self.a >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("SBC ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //cmp absolute
+                0xcd => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
                             let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
-                            self.cpu_sbc(self.temp);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                            self.disassembly = format!("CMP ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //sbc absolute x
-                    0xfd => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.a == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("SBC ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if self.a >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.x);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.x as u16);
-                                self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.cpu_sbc(self.temp);
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
+                        if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //cmp absolute x
+                0xdd => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("CMP ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.x);
+                        if !overflow {
                             addr = addr.wrapping_add(self.x as u16);
                             self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.cpu_sbc(self.temp);
+                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                            if self.a == self.temp {
+                                self.p |= CPU_FLAG_ZERO;
+                            }
+                            if self.a >= self.temp {
+                                self.p |= CPU_FLAG_CARRY;
+                            }
+                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                                self.p |= CPU_FLAG_NEGATIVE;
+                            }
 
                             self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 4;
                         }
-                    },
-                    //sbc absolute y
-                    0xf9 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.x as u16);
+                        self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.a == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("SBC ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if self.a >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.y);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.y as u16);
-                                self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.cpu_sbc(self.temp);
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
+                        if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //cmp absolute y
+                0xd9 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("CMP ${:04x},Y", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.y);
+                        if !overflow {
                             addr = addr.wrapping_add(self.y as u16);
                             self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.cpu_sbc(self.temp);
+                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                            if self.a == self.temp {
+                                self.p |= CPU_FLAG_ZERO;
+                            }
+                            if self.a >= self.temp {
+                                self.p |= CPU_FLAG_CARRY;
+                            }
+                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                                self.p |= CPU_FLAG_NEGATIVE;
+                            }
 
                             self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 4;
                         }
-                    },
-                    //sbc indirect x
-                    0xe1 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("SBC (${:02x},X)", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.a == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        if self.a >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        4 => {
-                            let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.subcycle = 5;
+                        if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            self.cpu_sbc(self.temp);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //cmp indirect x
+                0xc1 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("CMP (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //sbc indirect y
-                    0xf1 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("SBC (${:02x}),Y", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.a == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        if self.a >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        4 => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            let (_val, overflow) = self.temp2.overflowing_add(self.y);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.y as u16);
-                                self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.cpu_sbc(self.temp);
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 5;
-                            }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //cmp indirect y
+                0xd1 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("CMP (${:02x}),Y", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        let (_val, overflow) = self.temp2.overflowing_add(self.y);
+                        if !overflow {
                             addr = addr.wrapping_add(self.y as u16);
                             self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.cpu_sbc(self.temp);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //inc increment zero page
-                    0xe6 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("INC ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.temp2 = self.temp2.wrapping_add(1);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.temp2 == 0 {
+                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                            if self.a == self.temp {
                                 self.p |= CPU_FLAG_ZERO;
                             }
-                            if (self.temp2 & 0x80) != 0 {
+                            if self.a >= self.temp {
+                                self.p |= CPU_FLAG_CARRY;
+                            }
+                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
                                 self.p |= CPU_FLAG_NEGATIVE;
                             }
-                            self.memory_cycle_write(
-                                self.temp as u16,
-                                self.temp2,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        _ => {
+
                             self.pc = self.pc.wrapping_add(2);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 5;
                         }
-                    },
-                    //inc increment zero page x
-                    0xf6 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("INC ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.subcycle = 2;
+                    }
+                    _ => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.a == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        if self.a >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            self.temp2 = self.temp2.wrapping_add(1);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.temp2 == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp2 & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.memory_cycle_write(
-                                self.temp as u16,
-                                self.temp2,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        4 => {
-                            self.subcycle = 5;
+
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //cpy, compare y immediate
+                0xc0 => {
+                    self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = format!("CPY #${:02x}", self.temp);
+                        self.done_fetching = true;
+                    }
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                    if self.y == self.temp {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    if self.y >= self.temp {
+                        self.p |= CPU_FLAG_CARRY;
+                    }
+                    if ((self.y.wrapping_sub(self.temp)) & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    self.pc = self.pc.wrapping_add(2);
+                    self.end_instruction();
+                }
+                //cpy zero page
+                0xc4 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("CPY ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.y == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                    },
-                    //inc absolute
-                    0xee => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        if self.y >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("INC ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if ((self.y.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //cpy absolute
+                0xcc => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("CPY ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.temp = self.temp.wrapping_add(1);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.temp == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //inc absolute x
-                    0xfe => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.y == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("INC ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if self.y >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        if ((self.y.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.temp = self.temp.wrapping_add(1);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.temp == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 5;
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //cpx, compare x immediate
+                0xe0 => {
+                    self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = format!("CPX #${:02x}", self.temp);
+                        self.done_fetching = true;
+                    }
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                    if self.x == self.temp {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    if self.x >= self.temp {
+                        self.p |= CPU_FLAG_CARRY;
+                    }
+                    if ((self.x.wrapping_sub(self.temp)) & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    self.pc = self.pc.wrapping_add(2);
+                    self.end_instruction();
+                }
+                //cpx zero page
+                0xe4 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("CPX ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.subcycle = 6;
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.x == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        if self.x >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                    },
-                    //iny, increment y
-                    0xc8 => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("INY");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.y = self.y.wrapping_add(1);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.y & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            if self.y == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
+                        if ((self.x.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                    },
-                    //inx, increment x
-                    0xe8 => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("INX");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.x = self.x.wrapping_add(1);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.x & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            if self.x == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //cpx absolute
+                0xec => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("CPX ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //dec decrement zero page
-                    0xc6 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("DEC ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.x == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        if self.x >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            self.temp2 = self.temp2.wrapping_sub(1);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.temp2 == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp2 & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.memory_cycle_write(
-                                self.temp as u16,
-                                self.temp2,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        if ((self.x.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //jmp absolute
+                0x4c => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    _ => {
+                        let t2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        let newpc: u16 = (self.temp as u16) | (t2 as u16) << 8;
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("JMP ${:04x}", newpc);
+                            self.done_fetching = true;
+                        }
+                        self.pc = newpc;
+                        self.end_instruction();
+                    }
+                },
+                //jmp indirect
+                0x6c => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("jmp (${:04x})", temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //dec decrement zero page x
-                    0xd6 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("DEC ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.subcycle = 2;
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let temp = self.temp;
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.tempaddr = (self.temp2 as u16) << 8 | (temp.wrapping_add(1) as u16);
+                        self.subcycle = 4;
+                    }
+                    _ => {
+                        self.temp2 = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.pc = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.end_instruction();
+                    }
+                },
+                //sta, store a zero page
+                0x85 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("STA ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.subcycle = 2;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.temp as u16, self.a, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //sta, store a zero page x
+                0x95 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("STA ${:02x},X", self.temp);
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            self.temp2 = self.temp2.wrapping_sub(1);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.temp2 == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp2 & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.memory_cycle_write(
-                                self.temp as u16,
-                                self.temp2,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.memory_cycle_write(
+                            self.temp.wrapping_add(self.x) as u16,
+                            self.a,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //sta absolute
+                0x8d => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("STA ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.memory_cycle_write(temp, self.a, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //sta absolute x
+                0x9d => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("STA ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.subcycle = 4;
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.x as u16);
+                        self.memory_cycle_write(addr, self.a, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //sta absolute y
+                0x99 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("STA ${:04x},Y", temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //dec absolute
-                    0xce => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.subcycle = 4;
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.memory_cycle_write(addr, self.a, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //sta indirect x
+                0x81 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("STA (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("DEC ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.memory_cycle_write(addr, self.a, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //sta indirect y
+                0x91 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("STA (${:02x}),Y", self.temp);
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.memory_cycle_write(addr, self.a, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //ldx immediate
+                0xa2 => {
+                    self.x = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = format!("LDX #${:02x}", self.temp);
+                        self.done_fetching = true;
+                    }
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if self.x == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    if (self.x & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    self.pc = self.pc.wrapping_add(2);
+                    self.end_instruction();
+                }
+                //ldx zero page
+                0xa6 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("LDX ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.temp = self.temp.wrapping_sub(1);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.temp == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 5;
+                        self.subcycle = 2;
+                    }
+                    _ => {
+                        self.x = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.x == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        if (self.x & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                    },
-                    //dec absolute x
-                    0xde => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //ldx zero page y
+                0xb6 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("LDX ${:02x},Y", self.temp);
+                            self.done_fetching = true;
+                        }
+                        self.temp = self.temp.wrapping_add(self.y);
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.x = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.x == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("DEC ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.x & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //ldx absolute
+                0xae => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("LDX ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.temp = self.temp.wrapping_sub(1);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.temp == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 5;
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.x = self.memory_cycle_read(temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.x == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.subcycle = 6;
+                        if (self.x & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //ldx absolute y
+                0xbe => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("LDX ${:04x},Y", temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //dey, decrement y
-                    0x88 => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("DEY");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.y = self.y.wrapping_sub(1);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
+                        let (_val, overflow) = self.temp.overflowing_add(self.y);
+                        if !overflow {
+                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                            self.x = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
                             self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.y & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            if self.y == 0 {
+                            if self.x == 0 {
                                 self.p |= CPU_FLAG_ZERO;
                             }
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //dex, decrement x
-                    0xca => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("DEX");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.x = self.x.wrapping_sub(1);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
                             if (self.x & 0x80) != 0 {
                                 self.p |= CPU_FLAG_NEGATIVE;
                             }
-                            if self.x == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            self.pc = self.pc.wrapping_add(1);
+                            self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 4;
                         }
-                    },
-                    //tay, transfer accumulator to y
-                    0xa8 => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("TAY");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.y = self.a;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.y & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            if self.y == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
+                    }
+                    _ => {
+                        self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                        self.x = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.x == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                    },
-                    //tax, transfer accumulator to x
-                    0xaa => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("TAX");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.x = self.a;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.x & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            if self.x == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
+                        if (self.x & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                    },
-                    //tya, transfer y to accumulator
-                    0x98 => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("TYA");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.a = self.y;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //sty store y zero page
+                0x84 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("STY ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //txa, transfer x to accumulator
-                    0x8a => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("TXA");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.a = self.x;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.temp as u16, self.y, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //sty zero page x
+                0x94 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("STY ${:02x},X", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //tsx, transfer stack pointer to x
-                    0xba => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("TSX");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.x = self.s;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.x & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            if self.x == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.memory_cycle_write(
+                            self.temp.wrapping_add(self.x) as u16,
+                            self.y,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //sty absolute
+                0x8c => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("STY ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //txs, transfer x to stack pointer
-                    0x9a => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("TXS");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.s = self.x;
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.memory_cycle_write(temp, self.y, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //ldy load y immediate
+                0xa0 => {
+                    self.y = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = format!("LDY #${:02x}", self.temp);
+                        self.done_fetching = true;
+                    }
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if self.y == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    if (self.y & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    self.pc = self.pc.wrapping_add(2);
+                    self.end_instruction();
+                }
+                //ldy zero page
+                0xa4 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("LDY ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //bit zero page
-                    0x24 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("BIT ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        self.subcycle = 2;
+                    }
+                    _ => {
+                        self.y = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.y == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        _ => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_OVERFLOW | CPU_FLAG_NEGATIVE);
-                            self.p |= self.temp & (CPU_FLAG_OVERFLOW | CPU_FLAG_NEGATIVE);
-                            self.temp = self.a & self.temp;
-                            self.p &= !CPU_FLAG_ZERO;
-                            if self.temp == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        if (self.y & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                    },
-                    //bit absolute
-                    0x2c => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //ldy zero page x
+                0xb4 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("LDY ${:02x},X", self.temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("BIT ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.y = self.memory_cycle_read(
+                            self.temp.wrapping_add(self.x) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.y == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.y & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //ldy absolute
+                0xac => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("LDY ${:04x}", temp);
+                            self.done_fetching = true;
+                        }
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.y = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.y == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.y & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //ldy absolute x
+                0xbc => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
                             let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_OVERFLOW | CPU_FLAG_NEGATIVE);
-                            self.p |= self.temp & (CPU_FLAG_OVERFLOW | CPU_FLAG_NEGATIVE);
-                            self.temp = self.a & self.temp;
-                            self.p &= !CPU_FLAG_ZERO;
-                            if self.temp == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                            self.disassembly = format!("LDY ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //cmp, compare immediate
-                    0xc9 => match self.subcycle {
-                        _ => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("CMP #${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.a == self.temp {
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let addr =
+                            (self.temp2 as u16) << 8 | (self.temp.wrapping_add(self.x) as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.x);
+                        if !overflow {
+                            self.y = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                            if self.y == 0 {
                                 self.p |= CPU_FLAG_ZERO;
                             }
-                            if self.a >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            if (self.y & 0x80) != 0 {
                                 self.p |= CPU_FLAG_NEGATIVE;
                             }
-                            self.pc = self.pc.wrapping_add(2);
+                            self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 4;
                         }
-                    },
-                    //cmp zero page
-                    0xc5 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("CMP ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
+                    }
+                    _ => {
+                        let addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.y = self.memory_cycle_read(
+                            addr.wrapping_add(self.x as u16),
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.y == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.y & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //lda immediate
+                0xa9 => {
+                    self.a = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = format!("LDA #${:02x}", self.a);
+                        self.done_fetching = true;
+                    }
+                    self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if self.a == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    if (self.a & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    self.pc = self.pc.wrapping_add(2);
+                    self.end_instruction();
+                }
+                //lda zero page
+                0xa5 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("LDA ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.a == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.a >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.subcycle = 2;
+                    }
+                    _ => {
+                        self.a = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                    },
-                    //cmp zero page x
-                    0xd5 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("CMP ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        2 => {
-                            self.subcycle = 3;
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //lda zero page x
+                0xb5 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("LDA ${:02x},X", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(self.x) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.a == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.a >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.a = self.memory_cycle_read(
+                            self.temp.wrapping_add(self.x) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //lda absolute
+                0xad => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("LDA ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //cmp absolute
-                    0xcd => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.a = self.memory_cycle_read(temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("CMP ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.a == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.a >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //lda indirect x
+                0xa1 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("LDA (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //cmp absolute x
-                    0xdd => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("CMP ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.x);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.x as u16);
-                                self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                                if self.a == self.temp {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if self.a >= self.temp {
-                                    self.p |= CPU_FLAG_CARRY;
-                                }
-                                if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
-
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //lda absolute x
+                0xbd => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("LDA ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.x);
+                        if !overflow {
                             addr = addr.wrapping_add(self.x as u16);
-                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.a == self.temp {
+                            self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                            if self.a == 0 {
                                 self.p |= CPU_FLAG_ZERO;
                             }
-                            if self.a >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            if (self.a & 0x80) != 0 {
                                 self.p |= CPU_FLAG_NEGATIVE;
                             }
-
                             self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 4;
                         }
-                    },
-                    //cmp absolute y
-                    0xd9 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.x as u16);
+                        self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("CMP ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.y);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.y as u16);
-                                self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                                if self.a == self.temp {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if self.a >= self.temp {
-                                    self.p |= CPU_FLAG_CARRY;
-                                }
-                                if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
 
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //lda absolute y
+                0xb9 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("LDA ${:04x},Y", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.y);
+                        if !overflow {
                             addr = addr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.a == self.temp {
+                            self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                            if self.a == 0 {
                                 self.p |= CPU_FLAG_ZERO;
                             }
-                            if self.a >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            if (self.a & 0x80) != 0 {
                                 self.p |= CPU_FLAG_NEGATIVE;
                             }
-
                             self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 4;
                         }
-                    },
-                    //cmp indirect x
-                    0xc1 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("CMP (${:02x},X)", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                    }
+                    _ => {
+                        let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        4 => {
-                            let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.subcycle = 5;
+
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //lda indirect y
+                0xb1 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("LDA (${:02x}),Y", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.a == self.temp {
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        let (_val, overflow) = self.temp2.overflowing_add(self.y);
+                        if !overflow {
+                            addr = addr.wrapping_add(self.y as u16);
+                            self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                            if self.a == 0 {
                                 self.p |= CPU_FLAG_ZERO;
                             }
-                            if self.a >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            if (self.a & 0x80) != 0 {
                                 self.p |= CPU_FLAG_NEGATIVE;
                             }
                             self.pc = self.pc.wrapping_add(2);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 5;
                         }
-                    },
-                    //cmp indirect y
-                    0xd1 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("CMP (${:02x}),Y", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                    }
+                    _ => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        4 => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            let (_val, overflow) = self.temp2.overflowing_add(self.y);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.y as u16);
-                                self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                                if self.a == self.temp {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if self.a >= self.temp {
-                                    self.p |= CPU_FLAG_CARRY;
-                                }
-                                if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
 
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 5;
-                            }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //stx zero page
+                0x86 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("STX ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            addr = addr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.a == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.a >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.subcycle = 2;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.temp as u16, self.x, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //stx zero page y
+                0x96 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("STX ${:02x},Y", self.temp);
+                            self.done_fetching = true;
+                        }
+                        self.temp = self.temp.wrapping_add(self.y);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.temp as u16, self.x, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //stx, store x absolute
+                0x8e => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("STX ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //cpy, compare y immediate
-                    0xc0 => match self.subcycle {
-                        _ => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("CPY #${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.y == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.y >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.y.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.memory_cycle_write(temp, self.x, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //lsr logical shift right, accumulator
+                0x4a => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "LSR A".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if (self.a & 1) != 0 {
+                        self.p |= CPU_FLAG_CARRY;
+                    }
+                    self.a >>= 1;
+                    if self.a == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    if (self.a & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //lsr zero page
+                0x46 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("LSR ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //cpy zero page
-                    0xc4 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("CPY ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp2 & 1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        _ => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.y == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.y >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.y.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.temp2 >>= 1;
+                        if self.temp2 == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                    },
-                    //cpy absolute
-                    0xcc => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("CPY ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.memory_cycle_write(self.temp as u16, self.temp2, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //lsr zero page x
+                0x56 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("LSR ${:02x},X", self.temp);
+                            self.done_fetching = true;
+                        }
+                        self.temp = self.temp.wrapping_add(self.x);
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp2 & 1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        _ => {
-                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.y == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.y >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.y.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        self.temp2 >>= 1;
+                        if self.temp2 == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                    },
-                    //cpx, compare x immediate
-                    0xe0 => match self.subcycle {
-                        _ => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("CPX #${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.x == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.x >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.x.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                    },
-                    //cpx zero page
-                    0xe4 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("CPX ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.memory_cycle_write(self.temp as u16, self.temp2, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //lsr absolute
+                0x4e => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("LSR ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.x == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.x >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.x.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                    },
-                    //cpx absolute
-                    0xec => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.temp >>= 1;
+                        if self.temp == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("CPX ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //lsr absolute x
+                0x5e => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
                             let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.temp = self.memory_cycle_read(temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.x == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.x >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.x.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //jmp absolute
-                    0x4c => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        _ => {
-                            let t2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            let newpc: u16 = (self.temp as u16) | (t2 as u16) << 8;
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("JMP ${:04x}", newpc);
-                                self.done_fetching = true;
-                            }
-                            self.pc = newpc;
-                            self.end_instruction();
-                        }
-                    },
-                    //jmp indirect
-                    0x6c => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                            self.disassembly = format!("LSR ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("jmp (${:04x})", temp);
-                                self.done_fetching = true;
-                            }
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.subcycle = 3;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            let temp = self.temp;
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.tempaddr =
-                                (self.temp2 as u16) << 8 | (temp.wrapping_add(1) as u16);
-                            self.subcycle = 4;
+                        self.temp >>= 1;
+                        if self.temp == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        _ => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.pc = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.end_instruction();
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                    },
-                    //sta, store a zero page
-                    0x85 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("STA ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //asl, arithmetic shift left accumulator
+                0x0a => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "ASL A".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if (self.a & 0x80) != 0 {
+                        self.p |= CPU_FLAG_CARRY;
+                    }
+                    self.a <<= 1;
+                    if self.a == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    if (self.a & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //asl zero page
+                0x06 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("ASL ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.temp as u16, self.a, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                    },
-                    //sta, store a zero page x
-                    0x95 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("STA ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        self.temp2 <<= 1;
+                        if self.temp2 == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.subcycle = 3;
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            self.memory_cycle_write(
-                                self.temp.wrapping_add(self.x) as u16,
-                                self.a,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.memory_cycle_write(self.temp as u16, self.temp2, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //asl zero page x
+                0x16 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("ASL ${:02x},X", self.temp);
+                            self.done_fetching = true;
+                        }
+                        self.temp = self.temp.wrapping_add(self.x);
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                    },
-                    //sta absolute
-                    0x8d => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.temp2 <<= 1;
+                        if self.temp2 == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("STA ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.memory_cycle_write(self.temp as u16, self.temp2, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //asl absolute
+                0x0e => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
                             let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.memory_cycle_write(temp, self.a, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                            self.disassembly = format!("ASL ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //sta absolute x
-                    0x9d => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("STA ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            self.subcycle = 4;
+                        self.temp <<= 1;
+                        if self.temp == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            addr = addr.wrapping_add(self.x as u16);
-                            self.memory_cycle_write(addr, self.a, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                    },
-                    //sta absolute y
-                    0x99 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //asl absolute x
+                0x1e => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("ASL ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("STA ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            self.subcycle = 4;
+                        self.temp <<= 1;
+                        if self.temp == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            addr = addr.wrapping_add(self.y as u16);
-                            self.memory_cycle_write(addr, self.a, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                    },
-                    //sta indirect x
-                    0x81 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("STA (${:02x},X)", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //ror rotate right accumulator
+                0x6a => {
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "ROR A".to_string();
+                        self.done_fetching = true;
+                    }
+                    let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                    self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if (self.a & 1) != 0 {
+                        self.p |= CPU_FLAG_CARRY;
+                    }
+                    self.a >>= 1;
+                    if old_carry {
+                        self.a |= 0x80;
+                    }
+                    if self.a == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    if (self.a & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //ror zero page
+                0x66 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("ROR ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp2 & 1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        self.temp2 >>= 1;
+                        if old_carry {
+                            self.temp2 |= 0x80;
                         }
-                        4 => {
-                            let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            self.memory_cycle_write(addr, self.a, bus, cpu_peripherals);
-                            self.subcycle = 5;
+                        if self.temp2 == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                    },
-                    //sta indirect y
-                    0x91 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("STA (${:02x}),Y", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.memory_cycle_write(self.temp as u16, self.temp2, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //ror zero page x
+                0x76 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("ROR ${:02x},X", self.temp);
+                            self.done_fetching = true;
+                        }
+                        self.temp = self.temp.wrapping_add(self.x);
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp2 & 1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.temp2 >>= 1;
+                        if old_carry {
+                            self.temp2 |= 0x80;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        if self.temp2 == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            addr = addr.wrapping_add(self.y as u16);
-                            self.memory_cycle_write(addr, self.a, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //ldx immediate
-                    0xa2 => match self.subcycle {
-                        _ => {
-                            self.x = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("LDX #${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.x == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.x & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //ldx zero page
-                    0xa6 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("LDX ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        _ => {
-                            self.x = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.x == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.x & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //ldx zero page y
-                    0xb6 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("LDX ${:02x},Y", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.temp = self.temp.wrapping_add(self.y);
-                        }
-                        2 => {
-                            self.subcycle = 3;
-                        }
-                        _ => {
-                            self.x = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.x == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.x & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //ldx absolute
-                    0xae => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("LDX ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        _ => {
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.memory_cycle_write(self.temp as u16, self.temp2, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //ror absolute
+                0x6e => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
                             let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.x = self.memory_cycle_read(temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.x == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.x & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //ldx absolute y
-                    0xbe => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("LDX ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
-                            let (_val, overflow) = self.temp.overflowing_add(self.y);
-                            if !overflow {
-                                self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                                self.x =
-                                    self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.x == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.x & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
-                        }
-                        _ => {
-                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                            self.x = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.x == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.x & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //sty store y zero page
-                    0x84 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("STY ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
+                            self.disassembly = format!("ROR ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.temp as u16, self.y, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //sty zero page x
-                    0x94 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("STY ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
-                        }
-                        2 => {
-                            self.subcycle = 3;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        _ => {
-                            self.memory_cycle_write(
-                                self.temp.wrapping_add(self.x) as u16,
-                                self.y,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.temp >>= 1;
+                        if old_carry {
+                            self.temp |= 0x80;
                         }
-                    },
-                    //sty absolute
-                    0x8c => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        if self.temp == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("STY ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //ror absolute x
+                0x7e => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
                             let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.memory_cycle_write(temp, self.y, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //ldy load y immediate
-                    0xa0 => match self.subcycle {
-                        _ => {
-                            self.y = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("LDY #${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.y == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.y & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //ldy zero page
-                    0xa4 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("LDY ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        _ => {
-                            self.y = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.y == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.y & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //ldy zero page x
-                    0xb4 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("LDY ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.subcycle = 3;
-                        }
-                        _ => {
-                            self.y = self.memory_cycle_read(
-                                self.temp.wrapping_add(self.x) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.y == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.y & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //ldy absolute
-                    0xac => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("LDY ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        _ => {
-                            let addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.y = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.y == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.y & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //ldy absolute x
-                    0xbc => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("LDY ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            let addr =
-                                (self.temp2 as u16) << 8 | (self.temp.wrapping_add(self.x) as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.x);
-                            if !overflow {
-                                self.y = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.y == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.y & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
-                        }
-                        _ => {
-                            let addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.y = self.memory_cycle_read(
-                                addr.wrapping_add(self.x as u16),
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.y == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.y & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //lda immediate
-                    0xa9 => match self.subcycle {
-                        _ => {
-                            self.a = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("LDA #${:02x}", self.a);
-                                self.done_fetching = true;
-                            }
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //lda zero page
-                    0xa5 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("LDA ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        _ => {
-                            self.a = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                            self.disassembly = format!("ROR ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //lda zero page x
-                    0xb5 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("LDA ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.subcycle = 3;
-                        }
-                        _ => {
-                            self.a = self.memory_cycle_read(
-                                self.temp.wrapping_add(self.x) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //lda absolute
-                    0xad => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("LDA ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.temp >>= 1;
+                        if old_carry {
+                            self.temp |= 0x80;
                         }
-                        _ => {
-                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.a = self.memory_cycle_read(temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        if self.temp == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                    },
-                    //lda indirect x
-                    0xa1 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("LDA (${:02x},X)", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        2 => {
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //rol accumulator
+                0x2a => {
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "ROL A".to_string();
+                        self.done_fetching = true;
+                    }
+                    let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                    self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                    if (self.a & 0x80) != 0 {
+                        self.p |= CPU_FLAG_CARRY;
+                    }
+                    self.a <<= 1;
+                    if old_carry {
+                        self.a |= 0x1;
+                    }
+                    if self.a == 0 {
+                        self.p |= CPU_FLAG_ZERO;
+                    }
+                    if (self.a & 0x80) != 0 {
+                        self.p |= CPU_FLAG_NEGATIVE;
+                    }
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //rol zero page
+                0x26 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("ROL ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            let addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //lda absolute x
-                    0xbd => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("LDA ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.x);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.x as u16);
-                                self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.a == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.a & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
-                        }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            addr = addr.wrapping_add(self.x as u16);
-                            self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //lda absolute y
-                    0xb9 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("LDA ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.y);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.y as u16);
-                                self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.a == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.a & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
-                        }
-                        _ => {
-                            let mut addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            addr = addr.wrapping_add(self.y as u16);
-                            self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //lda indirect y
-                    0xb1 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("LDA (${:02x}),Y", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            let (_val, overflow) = self.temp2.overflowing_add(self.y);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.y as u16);
-                                self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.a == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.a & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 5;
-                            }
-                        }
-                        _ => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            addr = addr.wrapping_add(self.y as u16);
-                            self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //stx zero page
-                    0x86 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("STX ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        _ => {
-                            self.memory_cycle_write(self.temp as u16, self.x, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //stx zero page y
-                    0x96 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("STX ${:02x},Y", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.temp = self.temp.wrapping_add(self.y);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.subcycle = 3;
-                        }
-                        _ => {
-                            self.memory_cycle_write(self.temp as u16, self.x, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //stx, store x absolute
-                    0x8e => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("STX ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        _ => {
-                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.memory_cycle_write(temp, self.x, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //lsr logical shift right, accumulator
-                    0x4a => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("LSR A");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.a & 1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.a = self.a >> 1;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //lsr zero page
-                    0x46 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("LSR ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp2 & 1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp2 = self.temp2 >> 1;
-                            if self.temp2 == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp2 & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.memory_cycle_write(
-                                self.temp as u16,
-                                self.temp2,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //lsr zero page x
-                    0x56 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("LSR ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.temp = self.temp.wrapping_add(self.x);
-                        }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp2 & 1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp2 = self.temp2 >> 1;
-                            if self.temp2 == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp2 & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.memory_cycle_write(
-                                self.temp as u16,
-                                self.temp2,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //lsr absolute
-                    0x4e => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("LSR ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            if self.temp == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //lsr absolute x
-                    0x5e => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("LSR ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            if self.temp == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 5;
-                        }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.subcycle = 6;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //asl, arithmetic shift left accumulator
-                    0x0a => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ASL A");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.a = self.a << 1;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //asl zero page
-                    0x06 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ASL ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                        }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp2 & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp2 = self.temp2 << 1;
-                            if self.temp2 == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp2 & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.memory_cycle_write(
-                                self.temp as u16,
-                                self.temp2,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //asl zero page x
-                    0x16 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ASL ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.temp = self.temp.wrapping_add(self.x);
-                        }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp2 & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp2 = self.temp2 << 1;
-                            if self.temp2 == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp2 & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.memory_cycle_write(
-                                self.temp as u16,
-                                self.temp2,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //asl absolute
-                    0x0e => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("ASL ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            if self.temp == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //asl absolute x
-                    0x1e => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("ASL ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            if self.temp == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 5;
-                        }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.subcycle = 6;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //ror rotate right accumulator
-                    0x6a => match self.subcycle {
-                        _ => {
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ROR A");
-                                self.done_fetching = true;
-                            }
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.a & 1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.a = self.a >> 1;
-                            if old_carry {
-                                self.a |= 0x80;
-                            }
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //ror zero page
-                    0x66 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ROR ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                        }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp2 & 1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp2 = self.temp2 >> 1;
-                            if old_carry {
-                                self.temp2 |= 0x80;
-                            }
-                            if self.temp2 == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp2 & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.memory_cycle_write(
-                                self.temp as u16,
-                                self.temp2,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //ror zero page x
-                    0x76 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ROR ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.temp = self.temp.wrapping_add(self.x);
-                        }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp2 & 1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp2 = self.temp2 >> 1;
-                            if old_carry {
-                                self.temp2 |= 0x80;
-                            }
-                            if self.temp2 == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp2 & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.memory_cycle_write(
-                                self.temp as u16,
-                                self.temp2,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //ror absolute
-                    0x6e => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("ROR ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            if old_carry {
-                                self.temp |= 0x80;
-                            }
-                            if self.temp == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //ror absolute x
-                    0x7e => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("ROR ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            if old_carry {
-                                self.temp |= 0x80;
-                            }
-                            if self.temp == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 5;
-                        }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.subcycle = 6;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //rol accumulator
-                    0x2a => match self.subcycle {
-                        _ => {
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ROL A");
-                                self.done_fetching = true;
-                            }
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.a = self.a << 1;
-                            if old_carry {
-                                self.a |= 0x1;
-                            }
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //rol zero page
-                    0x26 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ROL ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                        }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp2 & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp2 = self.temp2 << 1;
-                            if old_carry {
-                                self.temp2 |= 1;
-                            }
-                            if self.temp2 == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp2 & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.memory_cycle_write(
-                                self.temp as u16,
-                                self.temp2,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //rol zero page x
-                    0x36 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("ROL ${:02x},X", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.temp = self.temp.wrapping_add(self.x);
-                        }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp2 & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp2 = self.temp2 << 1;
-                            if old_carry {
-                                self.temp2 |= 1;
-                            }
-                            if self.temp2 == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp2 & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.memory_cycle_write(
-                                self.temp as u16,
-                                self.temp2,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //rol absolute
-                    0x2e => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("ROL ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            if old_carry {
-                                self.temp |= 1;
-                            }
-                            if self.temp == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //rol absolute x
-                    0x3e => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("ROL ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            if old_carry {
-                                self.temp |= 1;
-                            }
-                            if self.temp == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 5;
-                        }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.subcycle = 6;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //rti, return from interrupt
-                    0x40 => match self.subcycle {
-                        1 => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("RTI");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.s = self.s.wrapping_add(1);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.p =
-                                self.memory_cycle_read(0x100 + self.s as u16, bus, cpu_peripherals);
-                            self.p = self.p & !CPU_FLAG_B1;
-                            self.p |= CPU_FLAG_B2;
-                            self.s = self.s.wrapping_add(1);
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.temp =
-                                self.memory_cycle_read(0x100 + self.s as u16, bus, cpu_peripherals);
-                            self.s = self.s.wrapping_add(1);
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.temp2 =
-                                self.memory_cycle_read(0x100 + self.s as u16, bus, cpu_peripherals);
-                            self.pc = (self.temp2 as u16) << 8 | self.temp as u16;
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.end_instruction();
-                        }
-                    },
-                    //jsr absolute
-                    0x20 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.memory_cycle_read(0x100 + self.s as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            let pc = (self.pc + 2).to_le_bytes();
-                            self.memory_cycle_write(
-                                0x100 + self.s as u16,
-                                pc[1],
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.s = self.s.wrapping_sub(1);
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            let pc = (self.pc + 2).to_le_bytes();
-                            self.memory_cycle_write(
-                                0x100 + self.s as u16,
-                                pc[0],
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.s = self.s.wrapping_sub(1);
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            let t2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            let newpc: u16 = (self.temp as u16) | (t2 as u16) << 8;
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("JSR ${:04x}", newpc);
-                                self.done_fetching = true;
-                            }
-                            self.pc = newpc;
-                            self.end_instruction();
-                        }
-                    },
-                    //nop
-                    0x1a | 0x3a | 0x5a | 0x7a | 0xda | 0xea | 0xfa => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("NOP");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(1);
-                            self.subcycle = 0;
-                            self.opcode = None;
-                        }
-                    },
-                    //extra nop
-                    0x04 | 0x44 | 0x64 => match self.subcycle {
-                        1 => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("NOP");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.subcycle = 0;
-                            self.opcode = None;
-                        }
-                    },
-                    //extra nop
-                    0x0c => match self.subcycle {
-                        1 => {
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("NOP");
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(3);
-                            self.subcycle = 0;
-                            self.opcode = None;
-                        }
-                    },
-                    //extra nop
-                    0x14 | 0x34 | 0x54 | 0x74 | 0xd4 | 0xf4 => match self.subcycle {
-                        1 => {
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("NOP");
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.subcycle = 3;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.subcycle = 0;
-                            self.opcode = None;
-                        }
-                    },
-                    //extra nop
-                    0x1c | 0x3c | 0x5c | 0x7c | 0xdc | 0xfc => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("NOP");
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            let (_val, overflow) = self.temp.overflowing_add(self.x);
-                            if overflow {
-                                self.subcycle = 4;
-                            } else {
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            }
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //extra nop
-                    0x80 => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("NOP");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.subcycle = 0;
-                            self.opcode = None;
-                        }
-                    },
-                    //clv, clear overflow flag
-                    0xb8 => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("CLV");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.p &= !CPU_FLAG_OVERFLOW;
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //sec set carry flag
-                    0x38 => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("SEC");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.p |= CPU_FLAG_CARRY;
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //sei set interrupt disable flag
-                    0x78 => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("SEI");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.p |= CPU_FLAG_INT_DISABLE;
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //sed set decimal flag
-                    0xf8 => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("SED");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.p |= CPU_FLAG_DECIMAL;
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //cld, clear decimal flag
-                    0xd8 => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("CLD");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.p &= !CPU_FLAG_DECIMAL;
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //clc clear carry flag
-                    0x18 => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("CLC");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.p &= !CPU_FLAG_CARRY;
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //cli clear interrupt disable
-                    0x58 => match self.subcycle {
-                        _ => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("CLI");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.p &= !CPU_FLAG_INT_DISABLE;
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //beq, branch if equal (zero flag set)
-                    0xf0 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
-                                self.disassembly = format!("BEQ ${:04X}", tempaddr);
-                                self.done_fetching = true;
-                            }
-                            if (self.p & CPU_FLAG_ZERO) != 0 {
-                                self.pc = self.pc.wrapping_add(2);
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                self.tempaddr = self.pc.wrapping_add(adjust);
-                                self.subcycle = 2;
-                            } else {
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            }
-                        }
-                        2 => {
-                            self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            let pc = self.pc.to_le_bytes();
-                            let pc2 = self.tempaddr.to_le_bytes();
-                            self.pc = self.tempaddr;
-                            if pc[1] != pc2[1] {
-                                self.subcycle = 3;
-                            } else {
-                                self.end_instruction();
-                            }
-                        }
-                        _ => {
-                            self.end_instruction();
-                        }
-                    },
-                    //bne, branch if not equal (zero flag not set)
-                    0xd0 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
-                                self.disassembly = format!("BNE ${:04X}", tempaddr);
-                                self.done_fetching = true;
-                            }
-                            if (self.p & CPU_FLAG_ZERO) == 0 {
-                                self.pc = self.pc.wrapping_add(2);
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                self.tempaddr = self.pc.wrapping_add(adjust);
-                                self.subcycle = 2;
-                            } else {
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            }
-                        }
-                        2 => {
-                            self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            let pc = self.pc.to_le_bytes();
-                            let pc2 = self.tempaddr.to_le_bytes();
-                            self.pc = self.tempaddr;
-                            if pc[1] != pc2[1] {
-                                self.subcycle = 3;
-                            } else {
-                                self.end_instruction();
-                            }
-                        }
-                        _ => {
-                            self.end_instruction();
-                        }
-                    },
-                    //bvs, branch if overflow set
-                    0x70 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
-                                self.disassembly = format!("BVS ${:04X}", tempaddr);
-                                self.done_fetching = true;
-                            }
-                            if (self.p & CPU_FLAG_OVERFLOW) != 0 {
-                                self.pc = self.pc.wrapping_add(2);
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                self.tempaddr = self.pc.wrapping_add(adjust);
-                                self.subcycle = 2;
-                            } else {
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            }
-                        }
-                        2 => {
-                            self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            let pc = self.pc.to_le_bytes();
-                            let pc2 = self.tempaddr.to_le_bytes();
-                            self.pc = self.tempaddr;
-                            if pc[1] != pc2[1] {
-                                self.subcycle = 3;
-                            } else {
-                                self.end_instruction();
-                            }
-                        }
-                        _ => {
-                            self.end_instruction();
-                        }
-                    },
-                    //bvc branch if overflow clear
-                    0x50 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
-                                self.disassembly = format!("BVC ${:04X}", tempaddr);
-                                self.done_fetching = true;
-                            }
-                            if (self.p & CPU_FLAG_OVERFLOW) == 0 {
-                                self.pc = self.pc.wrapping_add(2);
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                self.tempaddr = self.pc.wrapping_add(adjust);
-                                self.subcycle = 2;
-                            } else {
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            }
-                        }
-                        2 => {
-                            self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            let pc = self.pc.to_le_bytes();
-                            let pc2 = self.tempaddr.to_le_bytes();
-                            self.pc = self.tempaddr;
-                            if pc[1] != pc2[1] {
-                                self.subcycle = 3;
-                            } else {
-                                self.end_instruction();
-                            }
-                        }
-                        _ => {
-                            self.end_instruction();
-                        }
-                    },
-                    //bpl, branch if negative clear
-                    0x10 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
-                                self.disassembly = format!("BPL ${:04X}", tempaddr);
-                                self.done_fetching = true;
-                            }
-                            if (self.p & CPU_FLAG_NEGATIVE) == 0 {
-                                self.pc = self.pc.wrapping_add(2);
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                self.tempaddr = self.pc.wrapping_add(adjust);
-                                self.subcycle = 2;
-                            } else {
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            }
-                        }
-                        2 => {
-                            self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            let pc = self.pc.to_le_bytes();
-                            let pc2 = self.tempaddr.to_le_bytes();
-                            self.pc = self.tempaddr;
-                            if pc[1] != pc2[1] {
-                                self.subcycle = 3;
-                            } else {
-                                self.end_instruction();
-                            }
-                        }
-                        _ => {
-                            self.end_instruction();
-                        }
-                    },
-                    //bmi branch if negative flag set
-                    0x30 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
-                                self.disassembly = format!("BMI ${:04X}", tempaddr);
-                                self.done_fetching = true;
-                            }
-                            if (self.p & CPU_FLAG_NEGATIVE) != 0 {
-                                self.pc = self.pc.wrapping_add(2);
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                self.tempaddr = self.pc.wrapping_add(adjust);
-                                self.subcycle = 2;
-                            } else {
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            }
-                        }
-                        2 => {
-                            self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            let pc = self.pc.to_le_bytes();
-                            let pc2 = self.tempaddr.to_le_bytes();
-                            self.pc = self.tempaddr;
-                            if pc[1] != pc2[1] {
-                                self.subcycle = 3;
-                            } else {
-                                self.end_instruction();
-                            }
-                        }
-                        _ => {
-                            self.end_instruction();
-                        }
-                    },
-                    //bcs, branch if carry set
-                    0xb0 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
-                                self.disassembly = format!("BCS ${:04X}", tempaddr);
-                                self.done_fetching = true;
-                            }
-                            if (self.p & CPU_FLAG_CARRY) != 0 {
-                                self.pc = self.pc.wrapping_add(2);
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                self.tempaddr = self.pc.wrapping_add(adjust);
-                                self.subcycle = 2;
-                            } else {
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            }
-                        }
-                        2 => {
-                            self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            let pc = self.pc.to_le_bytes();
-                            let pc2 = self.tempaddr.to_le_bytes();
-                            self.pc = self.tempaddr;
-                            if pc[1] != pc2[1] {
-                                self.subcycle = 3;
-                            } else {
-                                self.end_instruction();
-                            }
-                        }
-                        _ => {
-                            self.end_instruction();
-                        }
-                    },
-                    //bcc branch if carry flag clear
-                    0x90 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
-                                self.disassembly = format!("BCC ${:04X}", tempaddr);
-                                self.done_fetching = true;
-                            }
-                            if (self.p & CPU_FLAG_CARRY) == 0 {
-                                self.pc = self.pc.wrapping_add(2);
-                                let mut adjust = self.temp as u16;
-                                if (self.temp & 0x80) != 0 {
-                                    adjust |= 0xff00;
-                                }
-                                self.tempaddr = self.pc.wrapping_add(adjust);
-                                self.subcycle = 2;
-                            } else {
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            }
-                        }
-                        2 => {
-                            self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            let pc = self.pc.to_le_bytes();
-                            let pc2 = self.tempaddr.to_le_bytes();
-                            self.pc = self.tempaddr;
-                            if pc[1] != pc2[1] {
-                                self.subcycle = 3;
-                            } else {
-                                self.end_instruction();
-                            }
-                        }
-                        _ => {
-                            self.end_instruction();
-                        }
-                    },
-                    //pha push accumulator
-                    0x48 => match self.subcycle {
-                        1 => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("PHA");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_write(
-                                0x100 + self.s as u16,
-                                self.a,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 2;
-                        }
-                        _ => {
-                            self.s = self.s.wrapping_sub(1);
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //php push processor status
-                    0x08 => match self.subcycle {
-                        1 => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("PHP");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_write(
-                                0x100 + self.s as u16,
-                                self.p | CPU_FLAG_B1,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 2;
-                        }
-                        _ => {
-                            self.s = self.s.wrapping_sub(1);
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //plp, pull processor status
-                    0x28 => match self.subcycle {
-                        1 => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("PLP");
-                                self.done_fetching = true;
-                            }
-                            self.s = self.s.wrapping_add(1);
-                            self.p =
-                                self.memory_cycle_read(0x100 + self.s as u16, bus, cpu_peripherals);
-                            self.p = self.p & !CPU_FLAG_B1;
-                            self.p |= CPU_FLAG_B2;
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.subcycle = 3;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //pla, pull accumulator
-                    0x68 => match self.subcycle {
-                        1 => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("PLA");
-                                self.done_fetching = true;
-                            }
-                            self.s = self.s.wrapping_add(1);
-                            self.a =
-                                self.memory_cycle_read(0x100 + self.s as u16, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.subcycle = 3;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //rts, return from subroutine
-                    0x60 => match self.subcycle {
-                        1 => {
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("RTS");
-                                self.done_fetching = true;
-                            }
-                            self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.memory_cycle_read(self.s as u16 + 0x100, bus, cpu_peripherals);
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.s = self.s.wrapping_add(1);
-                            self.temp =
-                                self.memory_cycle_read(self.s as u16 + 0x100, bus, cpu_peripherals);
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.pc = self.temp as u16;
-                            self.s = self.s.wrapping_add(1);
-                            self.pc |= (self.memory_cycle_read(
-                                self.s as u16 + 0x100,
-                                bus,
-                                cpu_peripherals,
-                            ) as u16)
-                                << 8;
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(1);
-                            self.end_instruction();
-                        }
-                    },
-                    //lax (indirect x)?, undocumented
-                    0xa3 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*LAX (${:02x},X)", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.tempaddr = self.temp.wrapping_add(self.x) as u16;
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.temp2 = self.memory_cycle_read(
-                                self.tempaddr.wrapping_add(1),
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.a = self.temp;
-                            self.x = self.temp;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //lax zero page?, undocumented
-                    0xa7 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*LAX ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        _ => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.a = self.temp;
-                            self.x = self.temp;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //lax absolute, undocumented
-                    0xaf => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*LAX ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        _ => {
-                            let addr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.a = self.temp;
-                            self.x = self.temp;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //lax indirect y, undocumented
-                    0xb3 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*LAX (${:02x}),Y", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            let (_val, overflow) = self.temp2.overflowing_add(self.y);
-                            if !overflow {
-                                addr = addr.wrapping_add(self.y as u16);
-                                self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                                self.x = self.a;
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.a == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.a & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
-                                self.pc = self.pc.wrapping_add(2);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 5;
-                            }
-                        }
-                        _ => {
-                            let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            addr = addr.wrapping_add(self.y as u16);
-                            self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
-                            self.x = self.a;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //lax zero page y, undocumented
-                    0xb7 => match self.subcycle {
-                        1 => {
-                            self.subcycle = 2;
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*LAX ${:02x},Y", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.temp = self.temp.wrapping_add(self.y);
-                        }
-                        2 => {
-                            self.subcycle = 3;
-                        }
-                        _ => {
-                            self.x = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.a = self.x;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.x == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.x & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //lax absolute y, undocumented
-                    0xbf => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*LAX ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
-                            let (_val, overflow) = self.temp.overflowing_add(self.y);
-                            if !overflow {
-                                self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                                self.x =
-                                    self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                                self.a = self.x;
-                                self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                                if self.x == 0 {
-                                    self.p |= CPU_FLAG_ZERO;
-                                }
-                                if (self.x & 0x80) != 0 {
-                                    self.p |= CPU_FLAG_NEGATIVE;
-                                }
-                                self.pc = self.pc.wrapping_add(3);
-                                self.end_instruction();
-                            } else {
-                                self.subcycle = 4;
-                            }
-                        }
-                        _ => {
-                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                            self.x = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.a = self.x;
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if self.x == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.x & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //sax indirect x
-                    0x83 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*SAX (${:02x},X)", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.tempaddr = self.temp.wrapping_add(self.x) as u16;
-                            self.temp2 =
-                                self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.tempaddr = self.temp.wrapping_add(self.x).wrapping_add(1) as u16;
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.tempaddr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            self.temp = self.x & self.a;
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //sax zero page
-                    0x87 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*SAX ${:02x}", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        _ => {
-                            self.temp2 = self.a & self.x;
-                            self.memory_cycle_write(
-                                self.temp as u16,
-                                self.temp2,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //sax absolute
-                    0x8f => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*SAX ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        _ => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.temp2 = self.a & self.x;
-                            self.memory_cycle_write(
-                                self.tempaddr,
-                                self.temp2,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //sax absolute y
-                    0x97 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*SAX ${:02x},Y", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.subcycle = 3;
-                        }
-                        _ => {
-                            self.tempaddr = self.temp.wrapping_add(self.y) as u16;
-                            self.temp2 = self.a & self.x;
-                            self.memory_cycle_write(
-                                self.tempaddr,
-                                self.temp2,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //dcp, undocumented, decrement and compare indirect x
-                    0xc3 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*DCP (${:02x},X)", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.tempaddr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 5;
-                        }
-                        5 => {
-                            self.subcycle = 6;
-                        }
-                        6 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.temp = self.temp.wrapping_sub(1);
-                            self.subcycle = 7;
-                        }
-                        _ => {
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.a == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.a >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //dcp zero page, undocumented
-                    0xc7 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*DCP ${:02x}", self.temp2);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.temp = self.temp.wrapping_sub(1);
-                            self.memory_cycle_write(
-                                self.temp2 as u16,
-                                self.temp,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        _ => {
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.a == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.a >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //dcp absolute, undocumented
-                    0xcf => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*DCP ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.temp = self.temp.wrapping_sub(1);
-                            self.subcycle = 5;
-                        }
-                        _ => {
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.a == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.a >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
-                        }
-                    },
-                    //dcp indirect y
-                    0xd3 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*DCP (${:02x}),Y", self.temp2);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            self.temp2 = self.memory_cycle_read(
-                                self.temp2.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        self.temp2 <<= 1;
+                        if old_carry {
+                            self.temp2 |= 1;
                         }
-                        4 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 5;
+                        if self.temp2 == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        5 => {
-                            self.subcycle = 6;
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        6 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.subcycle = 7;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.memory_cycle_write(self.temp as u16, self.temp2, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //rol zero page x
+                0x36 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("ROL ${:02x},X", self.temp);
+                            self.done_fetching = true;
+                        }
+                        self.temp = self.temp.wrapping_add(self.x);
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        _ => {
-                            self.temp = self.temp.wrapping_sub(1);
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.a == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.a >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.temp2 <<= 1;
+                        if old_carry {
+                            self.temp2 |= 1;
                         }
-                    },
-                    //dcp zero page x, undocumented
-                    0xd7 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*DCP ${:02x},X", self.temp2);
-                                self.done_fetching = true;
-                            }
-                            self.temp2 = self.temp2.wrapping_add(self.x);
-                            self.subcycle = 2;
+                        if self.temp2 == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        if (self.temp2 & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            self.temp = self.temp.wrapping_sub(1);
-                            self.memory_cycle_write(
-                                self.temp2 as u16,
-                                self.temp,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.memory_cycle_write(self.temp as u16, self.temp2, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //rol absolute
+                0x2e => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("ROL ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        _ => {
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.a == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.a >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.temp <<= 1;
+                        if old_carry {
+                            self.temp |= 1;
                         }
-                    },
-                    //dcp absolute y, undocumented
-                    0xdb => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        if self.temp == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*DCP ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //rol absolute x
+                0x3e => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("ROL ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.subcycle = 6;
+                        self.temp <<= 1;
+                        if old_carry {
+                            self.temp |= 1;
                         }
-                        _ => {
-                            self.temp = self.temp.wrapping_sub(1);
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.a == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.a >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        if self.temp == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                    },
-                    //dcp absolute x, undocumented
-                    0xdf => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*DCP ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //rti, return from interrupt
+                0x40 => match self.subcycle {
+                    1 => {
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = "RTI".to_string();
+                            self.done_fetching = true;
+                        }
+                        self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.s = self.s.wrapping_add(1);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.p =
+                            self.memory_cycle_read(0x100 + self.s as u16, bus, cpu_peripherals);
+                        self.p &= !CPU_FLAG_B1;
+                        self.p |= CPU_FLAG_B2;
+                        self.s = self.s.wrapping_add(1);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp =
+                            self.memory_cycle_read(0x100 + self.s as u16, bus, cpu_peripherals);
+                        self.s = self.s.wrapping_add(1);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.temp2 =
+                            self.memory_cycle_read(0x100 + self.s as u16, bus, cpu_peripherals);
+                        self.pc = (self.temp2 as u16) << 8 | self.temp as u16;
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.end_instruction();
+                    }
+                },
+                //jsr absolute
+                0x20 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.memory_cycle_read(0x100 + self.s as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let pc = (self.pc + 2).to_le_bytes();
+                        self.memory_cycle_write(0x100 + self.s as u16, pc[1], bus, cpu_peripherals);
+                        self.s = self.s.wrapping_sub(1);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let pc = (self.pc + 2).to_le_bytes();
+                        self.memory_cycle_write(0x100 + self.s as u16, pc[0], bus, cpu_peripherals);
+                        self.s = self.s.wrapping_sub(1);
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        let t2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        let newpc: u16 = (self.temp as u16) | (t2 as u16) << 8;
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("JSR ${:04x}", newpc);
+                            self.done_fetching = true;
+                        }
+                        self.pc = newpc;
+                        self.end_instruction();
+                    }
+                },
+                //nop
+                0x1a | 0x3a | 0x5a | 0x7a | 0xda | 0xea | 0xfa => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "NOP".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.pc = self.pc.wrapping_add(1);
+                    self.subcycle = 0;
+                    self.opcode = None;
+                }
+                //extra nop
+                0x04 | 0x44 | 0x64 => match self.subcycle {
+                    1 => {
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = "NOP".to_string();
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.subcycle = 0;
+                        self.opcode = None;
+                    }
+                },
+                //extra nop
+                0x0c => match self.subcycle {
+                    1 => {
+                        self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = "NOP".to_string();
+                            self.done_fetching = true;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(3);
+                        self.subcycle = 0;
+                        self.opcode = None;
+                    }
+                },
+                //extra nop
+                0x14 | 0x34 | 0x54 | 0x74 | 0xd4 | 0xf4 => match self.subcycle {
+                    1 => {
+                        self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = "NOP".to_string();
+                            self.done_fetching = true;
                         }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.temp = self.temp.wrapping_sub(1);
-                            self.subcycle = 6;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.subcycle = 0;
+                        self.opcode = None;
+                    }
+                },
+                //extra nop
+                0x1c | 0x3c | 0x5c | 0x7c | 0xdc | 0xfc => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = "NOP".to_string();
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
-                            if self.a == self.temp {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if self.a >= self.temp {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        let (_val, overflow) = self.temp.overflowing_add(self.x);
+                        if overflow {
+                            self.subcycle = 4;
+                        } else {
                             self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
                         }
-                    },
-                    //isb indirect x, increment memory, sub memory from accumulator, undocumented
-                    0xe3 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*ISB (${:02x},X)", self.temp);
-                                self.done_fetching = true;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //extra nop
+                0x80 => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "NOP".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.pc = self.pc.wrapping_add(2);
+                    self.subcycle = 0;
+                    self.opcode = None;
+                }
+                //clv, clear overflow flag
+                0xb8 => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "CLV".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.p &= !CPU_FLAG_OVERFLOW;
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //sec set carry flag
+                0x38 => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "SEC".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.p |= CPU_FLAG_CARRY;
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //sei set interrupt disable flag
+                0x78 => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "SEI".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.p |= CPU_FLAG_INT_DISABLE;
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //sed set decimal flag
+                0xf8 => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "SED".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.p |= CPU_FLAG_DECIMAL;
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //cld, clear decimal flag
+                0xd8 => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "CLD".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.p &= !CPU_FLAG_DECIMAL;
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //clc clear carry flag
+                0x18 => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "CLC".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.p &= !CPU_FLAG_CARRY;
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //cli clear interrupt disable
+                0x58 => {
+                    #[cfg(debug_assertions)]
+                    {
+                        self.disassembly = "CLI".to_string();
+                        self.done_fetching = true;
+                    }
+                    self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                    self.p &= !CPU_FLAG_INT_DISABLE;
+                    self.pc = self.pc.wrapping_add(1);
+                    self.end_instruction();
+                }
+                //beq, branch if equal (zero flag set)
+                0xf0 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
+                            }
+                            let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
+                            self.disassembly = format!("BEQ ${:04X}", tempaddr);
+                            self.done_fetching = true;
+                        }
+                        if (self.p & CPU_FLAG_ZERO) != 0 {
+                            self.pc = self.pc.wrapping_add(2);
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
                             }
+                            self.tempaddr = self.pc.wrapping_add(adjust);
                             self.subcycle = 2;
+                        } else {
+                            self.pc = self.pc.wrapping_add(2);
+                            self.end_instruction();
                         }
-                        2 => {
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                    }
+                    2 => {
+                        self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        let pc = self.pc.to_le_bytes();
+                        let pc2 = self.tempaddr.to_le_bytes();
+                        self.pc = self.tempaddr;
+                        if pc[1] != pc2[1] {
                             self.subcycle = 3;
+                        } else {
+                            self.end_instruction();
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.tempaddr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 5;
-                        }
-                        5 => {
-                            self.subcycle = 6;
-                        }
-                        6 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.temp = self.temp.wrapping_add(1);
-                            self.subcycle = 7;
+                    }
+                    _ => {
+                        self.end_instruction();
+                    }
+                },
+                //bne, branch if not equal (zero flag not set)
+                0xd0 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
+                            }
+                            let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
+                            self.disassembly = format!("BNE ${:04X}", tempaddr);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.cpu_sbc(self.temp);
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        if (self.p & CPU_FLAG_ZERO) == 0 {
                             self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //isb zero page, undocumented
-                    0xe7 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*ISB ${:02x}", self.temp2);
-                                self.done_fetching = true;
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
                             }
+                            self.tempaddr = self.pc.wrapping_add(adjust);
                             self.subcycle = 2;
+                        } else {
+                            self.pc = self.pc.wrapping_add(2);
+                            self.end_instruction();
                         }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                    }
+                    2 => {
+                        self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        let pc = self.pc.to_le_bytes();
+                        let pc2 = self.tempaddr.to_le_bytes();
+                        self.pc = self.tempaddr;
+                        if pc[1] != pc2[1] {
                             self.subcycle = 3;
+                        } else {
+                            self.end_instruction();
                         }
-                        3 => {
-                            self.temp = self.temp.wrapping_add(1);
-                            self.memory_cycle_write(
-                                self.temp2 as u16,
-                                self.temp,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                    }
+                    _ => {
+                        self.end_instruction();
+                    }
+                },
+                //bvs, branch if overflow set
+                0x70 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
+                            }
+                            let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
+                            self.disassembly = format!("BVS ${:04X}", tempaddr);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.cpu_sbc(self.temp);
+                        if (self.p & CPU_FLAG_OVERFLOW) != 0 {
                             self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //isb absolute, undocumented
-                    0xef => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
+                            }
+                            self.tempaddr = self.pc.wrapping_add(adjust);
                             self.subcycle = 2;
+                        } else {
+                            self.pc = self.pc.wrapping_add(2);
+                            self.end_instruction();
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*ISB ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
+                    }
+                    2 => {
+                        self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        let pc = self.pc.to_le_bytes();
+                        let pc2 = self.tempaddr.to_le_bytes();
+                        self.pc = self.tempaddr;
+                        if pc[1] != pc2[1] {
                             self.subcycle = 3;
+                        } else {
+                            self.end_instruction();
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                    }
+                    _ => {
+                        self.end_instruction();
+                    }
+                },
+                //bvc branch if overflow clear
+                0x50 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
+                            }
+                            let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
+                            self.disassembly = format!("BVC ${:04X}", tempaddr);
+                            self.done_fetching = true;
                         }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.temp = self.temp.wrapping_add(1);
-                            self.subcycle = 5;
+                        if (self.p & CPU_FLAG_OVERFLOW) == 0 {
+                            self.pc = self.pc.wrapping_add(2);
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
+                            }
+                            self.tempaddr = self.pc.wrapping_add(adjust);
+                            self.subcycle = 2;
+                        } else {
+                            self.pc = self.pc.wrapping_add(2);
+                            self.end_instruction();
                         }
-                        _ => {
-                            self.cpu_sbc(self.temp);
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
+                    }
+                    2 => {
+                        self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        let pc = self.pc.to_le_bytes();
+                        let pc2 = self.tempaddr.to_le_bytes();
+                        self.pc = self.tempaddr;
+                        if pc[1] != pc2[1] {
+                            self.subcycle = 3;
+                        } else {
                             self.end_instruction();
                         }
-                    },
-                    //isb indirect y, undocumented
-                    0xf3 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*ISB (${:02x}),Y", self.temp2);
-                                self.done_fetching = true;
+                    }
+                    _ => {
+                        self.end_instruction();
+                    }
+                },
+                //bpl, branch if negative clear
+                0x10 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
+                            }
+                            let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
+                            self.disassembly = format!("BPL ${:04X}", tempaddr);
+                            self.done_fetching = true;
+                        }
+                        if (self.p & CPU_FLAG_NEGATIVE) == 0 {
+                            self.pc = self.pc.wrapping_add(2);
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
                             }
+                            self.tempaddr = self.pc.wrapping_add(adjust);
                             self.subcycle = 2;
+                        } else {
+                            self.pc = self.pc.wrapping_add(2);
+                            self.end_instruction();
                         }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                    }
+                    2 => {
+                        self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        let pc = self.pc.to_le_bytes();
+                        let pc2 = self.tempaddr.to_le_bytes();
+                        self.pc = self.tempaddr;
+                        if pc[1] != pc2[1] {
                             self.subcycle = 3;
+                        } else {
+                            self.end_instruction();
                         }
-                        3 => {
-                            self.temp2 = self.memory_cycle_read(
-                                self.temp2.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 5;
-                        }
-                        5 => {
-                            self.subcycle = 6;
-                        }
-                        6 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.subcycle = 7;
+                    }
+                    _ => {
+                        self.end_instruction();
+                    }
+                },
+                //bmi branch if negative flag set
+                0x30 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
+                            }
+                            let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
+                            self.disassembly = format!("BMI ${:04X}", tempaddr);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.temp = self.temp.wrapping_add(1);
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.cpu_sbc(self.temp);
+                        if (self.p & CPU_FLAG_NEGATIVE) != 0 {
                             self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //isb zero page x, undocumented
-                    0xf7 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*ISB ${:02x},X", self.temp2);
-                                self.done_fetching = true;
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
                             }
-                            self.temp2 = self.temp2.wrapping_add(self.x);
+                            self.tempaddr = self.pc.wrapping_add(adjust);
                             self.subcycle = 2;
+                        } else {
+                            self.pc = self.pc.wrapping_add(2);
+                            self.end_instruction();
                         }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                    }
+                    2 => {
+                        self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        let pc = self.pc.to_le_bytes();
+                        let pc2 = self.tempaddr.to_le_bytes();
+                        self.pc = self.tempaddr;
+                        if pc[1] != pc2[1] {
                             self.subcycle = 3;
+                        } else {
+                            self.end_instruction();
                         }
-                        3 => {
-                            self.temp = self.temp.wrapping_add(1);
-                            self.memory_cycle_write(
-                                self.temp2 as u16,
-                                self.temp,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.subcycle = 5;
+                    }
+                    _ => {
+                        self.end_instruction();
+                    }
+                },
+                //bcs, branch if carry set
+                0xb0 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
+                            }
+                            let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
+                            self.disassembly = format!("BCS ${:04X}", tempaddr);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.cpu_sbc(self.temp);
+                        if (self.p & CPU_FLAG_CARRY) != 0 {
                             self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
-                        }
-                    },
-                    //isb absolute y, undocumented
-                    0xfb => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
+                            }
+                            self.tempaddr = self.pc.wrapping_add(adjust);
                             self.subcycle = 2;
+                        } else {
+                            self.pc = self.pc.wrapping_add(2);
+                            self.end_instruction();
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*ISB ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
+                    }
+                    2 => {
+                        self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        let pc = self.pc.to_le_bytes();
+                        let pc2 = self.tempaddr.to_le_bytes();
+                        self.pc = self.tempaddr;
+                        if pc[1] != pc2[1] {
                             self.subcycle = 3;
-                        }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.subcycle = 5;
-                        }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.temp = self.temp.wrapping_add(1);
-                            self.subcycle = 6;
-                        }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.cpu_sbc(self.temp);
-                            self.pc = self.pc.wrapping_add(3);
+                        } else {
                             self.end_instruction();
                         }
-                    },
-                    //isb absolute x, undocumented
-                    0xff => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*ISB ${:04x},X", temp);
-                                self.done_fetching = true;
+                    }
+                    _ => {
+                        self.end_instruction();
+                    }
+                },
+                //bcc branch if carry flag clear
+                0x90 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
                             }
-                            self.subcycle = 3;
-                        }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
-                        }
-                        4 => {
-                            self.subcycle = 5;
-                        }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.temp = self.temp.wrapping_add(1);
-                            self.subcycle = 6;
-                        }
-                        _ => {
-                            self.cpu_sbc(self.temp);
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                            let tempaddr = self.pc.wrapping_add(2).wrapping_add(adjust);
+                            self.disassembly = format!("BCC ${:04X}", tempaddr);
+                            self.done_fetching = true;
                         }
-                    },
-                    //slo shift left, then or with accumulator, undocumented
-                    //indirect x
-                    0x03 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*SLO (${:02x},X)", self.temp);
-                                self.done_fetching = true;
+                        if (self.p & CPU_FLAG_CARRY) == 0 {
+                            self.pc = self.pc.wrapping_add(2);
+                            let mut adjust = self.temp as u16;
+                            if (self.temp & 0x80) != 0 {
+                                adjust |= 0xff00;
                             }
+                            self.tempaddr = self.pc.wrapping_add(adjust);
                             self.subcycle = 2;
+                        } else {
+                            self.pc = self.pc.wrapping_add(2);
+                            self.end_instruction();
                         }
-                        2 => {
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                    }
+                    2 => {
+                        self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        let pc = self.pc.to_le_bytes();
+                        let pc2 = self.tempaddr.to_le_bytes();
+                        self.pc = self.tempaddr;
+                        if pc[1] != pc2[1] {
                             self.subcycle = 3;
+                        } else {
+                            self.end_instruction();
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                    }
+                    _ => {
+                        self.end_instruction();
+                    }
+                },
+                //pha push accumulator
+                0x48 => match self.subcycle {
+                    1 => {
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = "PHA".to_string();
+                            self.done_fetching = true;
+                        }
+                        self.memory_cycle_write(
+                            0x100 + self.s as u16,
+                            self.a,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 2;
+                    }
+                    _ => {
+                        self.s = self.s.wrapping_sub(1);
+                        self.pc = self.pc.wrapping_add(1);
+                        self.end_instruction();
+                    }
+                },
+                //php push processor status
+                0x08 => match self.subcycle {
+                    1 => {
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = "PHP".to_string();
+                            self.done_fetching = true;
+                        }
+                        self.memory_cycle_write(
+                            0x100 + self.s as u16,
+                            self.p | CPU_FLAG_B1,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 2;
+                    }
+                    _ => {
+                        self.s = self.s.wrapping_sub(1);
+                        self.pc = self.pc.wrapping_add(1);
+                        self.end_instruction();
+                    }
+                },
+                //plp, pull processor status
+                0x28 => match self.subcycle {
+                    1 => {
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = "PLP".to_string();
+                            self.done_fetching = true;
                         }
-                        4 => {
-                            self.tempaddr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 5;
+                        self.s = self.s.wrapping_add(1);
+                        self.p =
+                            self.memory_cycle_read(0x100 + self.s as u16, bus, cpu_peripherals);
+                        self.p &= !CPU_FLAG_B1;
+                        self.p |= CPU_FLAG_B2;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(1);
+                        self.end_instruction();
+                    }
+                },
+                //pla, pull accumulator
+                0x68 => match self.subcycle {
+                    1 => {
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = "PLA".to_string();
+                            self.done_fetching = true;
                         }
-                        5 => {
-                            self.subcycle = 6;
+                        self.s = self.s.wrapping_add(1);
+                        self.a =
+                            self.memory_cycle_read(0x100 + self.s as u16, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        6 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.subcycle = 7;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            self.p &= !(CPU_FLAG_NEGATIVE | CPU_FLAG_ZERO | CPU_FLAG_CARRY);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            self.a = self.a | self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(1);
+                        self.end_instruction();
+                    }
+                },
+                //rts, return from subroutine
+                0x60 => match self.subcycle {
+                    1 => {
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = "RTS".to_string();
+                            self.done_fetching = true;
                         }
-                    },
-                    //slo zero page, undocumented
-                    0x07 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*SLO ${:02x}", self.temp2);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.memory_cycle_read(self.s as u16 + 0x100, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.s = self.s.wrapping_add(1);
+                        self.temp =
+                            self.memory_cycle_read(self.s as u16 + 0x100, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.pc = self.temp as u16;
+                        self.s = self.s.wrapping_add(1);
+                        self.pc |=
+                            (self.memory_cycle_read(self.s as u16 + 0x100, bus, cpu_peripherals)
+                                as u16)
+                                << 8;
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(1);
+                        self.end_instruction();
+                    }
+                },
+                //lax (indirect x)?, undocumented
+                0xa3 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*LAX (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.tempaddr = self.temp.wrapping_add(self.x) as u16;
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp2 = self.memory_cycle_read(
+                            self.tempaddr.wrapping_add(1),
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.a = self.temp;
+                        self.x = self.temp;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //lax zero page?, undocumented
+                0xa7 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*LAX ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            self.p &= !(CPU_FLAG_NEGATIVE | CPU_FLAG_ZERO | CPU_FLAG_CARRY);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            self.memory_cycle_write(
-                                self.temp2 as u16,
-                                self.temp,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        self.subcycle = 2;
+                    }
+                    _ => {
+                        self.temp = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.a = self.temp;
+                        self.x = self.temp;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //lax absolute, undocumented
+                0xaf => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*LAX ${:04x}", temp);
+                            self.done_fetching = true;
+                        }
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        let addr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.temp = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.a = self.temp;
+                        self.x = self.temp;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //lax indirect y, undocumented
+                0xb3 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*LAX (${:02x}),Y", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.a = self.a | self.temp;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        let (_val, overflow) = self.temp2.overflowing_add(self.y);
+                        if !overflow {
+                            addr = addr.wrapping_add(self.y as u16);
+                            self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                            self.x = self.a;
+                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
                             if self.a == 0 {
                                 self.p |= CPU_FLAG_ZERO;
                             }
@@ -6671,1271 +5631,2072 @@ impl NesCpu {
                             }
                             self.pc = self.pc.wrapping_add(2);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 5;
                         }
-                    },
-                    //slo absolute, undocumented
-                    0x0f => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                    }
+                    _ => {
+                        let mut addr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        addr = addr.wrapping_add(self.y as u16);
+                        self.a = self.memory_cycle_read(addr, bus, cpu_peripherals);
+                        self.x = self.a;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*SLO ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //lax zero page y, undocumented
+                0xb7 => match self.subcycle {
+                    1 => {
+                        self.subcycle = 2;
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*LAX ${:02x},Y", self.temp);
+                            self.done_fetching = true;
+                        }
+                        self.temp = self.temp.wrapping_add(self.y);
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.x = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.a = self.x;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.x == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_NEGATIVE | CPU_FLAG_ZERO | CPU_FLAG_CARRY);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            self.subcycle = 5;
+                        if (self.x & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            self.a = self.a | self.temp;
-                            if self.a == 0 {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //lax absolute y, undocumented
+                0xbf => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*LAX ${:04x},Y", temp);
+                            self.done_fetching = true;
+                        }
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | self.temp as u16;
+                        let (_val, overflow) = self.temp.overflowing_add(self.y);
+                        if !overflow {
+                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                            self.x = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                            self.a = self.x;
+                            self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                            if self.x == 0 {
                                 self.p |= CPU_FLAG_ZERO;
                             }
-                            if (self.a & 0x80) != 0 {
+                            if (self.x & 0x80) != 0 {
                                 self.p |= CPU_FLAG_NEGATIVE;
                             }
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
                             self.pc = self.pc.wrapping_add(3);
                             self.end_instruction();
+                        } else {
+                            self.subcycle = 4;
                         }
-                    },
-                    //slo indirect y, undocumented
-                    0x13 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*SLO (${:02x}),Y", self.temp2);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
-                        }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                    }
+                    _ => {
+                        self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                        self.x = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.a = self.x;
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if self.x == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.x & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //sax indirect x
+                0x83 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*SAX (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            self.temp2 = self.memory_cycle_read(
-                                self.temp2.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.tempaddr = self.temp.wrapping_add(self.x) as u16;
+                        self.temp2 = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = self.temp.wrapping_add(self.x).wrapping_add(1) as u16;
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.tempaddr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.temp = self.x & self.a;
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //sax zero page
+                0x87 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*SAX ${:02x}", self.temp);
+                            self.done_fetching = true;
                         }
-                        4 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 5;
+                        self.subcycle = 2;
+                    }
+                    _ => {
+                        self.temp2 = self.a & self.x;
+                        self.memory_cycle_write(self.temp as u16, self.temp2, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //sax absolute
+                0x8f => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*SAX ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        5 => {
-                            self.subcycle = 6;
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.temp2 = self.a & self.x;
+                        self.memory_cycle_write(self.tempaddr, self.temp2, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //sax absolute y
+                0x97 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*SAX ${:02x},Y", self.temp);
+                            self.done_fetching = true;
                         }
-                        6 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.subcycle = 7;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.subcycle = 3;
+                    }
+                    _ => {
+                        self.tempaddr = self.temp.wrapping_add(self.y) as u16;
+                        self.temp2 = self.a & self.x;
+                        self.memory_cycle_write(self.tempaddr, self.temp2, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //dcp, undocumented, decrement and compare indirect x
+                0xc3 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*DCP (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.p &= !(CPU_FLAG_NEGATIVE | CPU_FLAG_ZERO | CPU_FLAG_CARRY);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.a = self.a | self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.tempaddr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.subcycle = 6;
+                    }
+                    6 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.temp = self.temp.wrapping_sub(1);
+                        self.subcycle = 7;
+                    }
+                    _ => {
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.a == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                    },
-                    //slo zero page x, undocumented
-                    0x17 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*SLO ${:02x},X", self.temp2);
-                                self.done_fetching = true;
-                            }
-                            self.temp2 = self.temp2.wrapping_add(self.x);
-                            self.subcycle = 2;
+                        if self.a >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            self.p &= !(CPU_FLAG_NEGATIVE | CPU_FLAG_ZERO | CPU_FLAG_CARRY);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            self.memory_cycle_write(
-                                self.temp2 as u16,
-                                self.temp,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //dcp zero page, undocumented
+                0xc7 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*DCP ${:02x}", self.temp2);
+                            self.done_fetching = true;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.temp.wrapping_sub(1);
+                        self.memory_cycle_write(self.temp2 as u16, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    _ => {
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.a == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        _ => {
-                            self.a = self.a | self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        if self.a >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                    },
-                    //slo absolute y, undocumented
-                    0x1b => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*SLO ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //dcp absolute, undocumented
+                0xcf => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*DCP ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.temp = self.temp.wrapping_sub(1);
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.a == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        if self.a >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_NEGATIVE | CPU_FLAG_ZERO | CPU_FLAG_CARRY);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            self.subcycle = 6;
+                        if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.a = self.a | self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //dcp indirect y
+                0xd3 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*DCP (${:02x}),Y", self.temp2);
+                            self.done_fetching = true;
                         }
-                    },
-                    //slo absolute x, undocumented
-                    0x1f => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp2 = self.memory_cycle_read(
+                            self.temp2.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.subcycle = 6;
+                    }
+                    6 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 7;
+                    }
+                    _ => {
+                        self.temp = self.temp.wrapping_sub(1);
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.a == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*SLO ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        if self.a >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //dcp zero page x, undocumented
+                0xd7 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*DCP ${:02x},X", self.temp2);
+                            self.done_fetching = true;
+                        }
+                        self.temp2 = self.temp2.wrapping_add(self.x);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.temp.wrapping_sub(1);
+                        self.memory_cycle_write(self.temp2 as u16, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.a == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_NEGATIVE | CPU_FLAG_ZERO | CPU_FLAG_CARRY);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            self.subcycle = 6;
+                        if self.a >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        _ => {
-                            self.a = self.a | self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                    },
-                    //rla, rotate left, then and with accumulator, undocumented
-                    //indirect x
-                    0x23 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*RLA (${:02x},X)", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //dcp absolute y, undocumented
+                0xdb => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*DCP ${:04x},Y", temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.temp = self.temp.wrapping_sub(1);
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.a == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        if self.a >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        4 => {
-                            self.tempaddr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 5;
+                        if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        5 => {
-                            self.subcycle = 6;
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //dcp absolute x, undocumented
+                0xdf => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*DCP ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        6 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            if old_carry {
-                                self.temp |= 0x1;
-                            }
-                            self.a = self.a & self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 7;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.temp = self.temp.wrapping_sub(1);
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.p &= !(CPU_FLAG_ZERO | CPU_FLAG_CARRY | CPU_FLAG_NEGATIVE);
+                        if self.a == self.temp {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        if self.a >= self.temp {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                    },
-                    //rla zero page, undocumented
-                    0x27 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*RLA ${:02x}", self.temp2);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        if ((self.a.wrapping_sub(self.temp)) & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //isb indirect x, increment memory, sub memory from accumulator, undocumented
+                0xe3 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*ISB (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            if old_carry {
-                                self.temp |= 0x1;
-                            }
-                            self.memory_cycle_write(
-                                self.temp2 as u16,
-                                self.temp,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.a = self.a & self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 4;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.tempaddr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.subcycle = 6;
+                    }
+                    6 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.temp = self.temp.wrapping_add(1);
+                        self.subcycle = 7;
+                    }
+                    _ => {
+                        self.cpu_sbc(self.temp);
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //isb zero page, undocumented
+                0xe7 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*ISB ${:02x}", self.temp2);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.temp.wrapping_add(1);
+                        self.memory_cycle_write(self.temp2 as u16, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    _ => {
+                        self.cpu_sbc(self.temp);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //isb absolute, undocumented
+                0xef => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*ISB ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //rla absolute, undocumented
-                    0x2f => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.temp = self.temp.wrapping_add(1);
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.cpu_sbc(self.temp);
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //isb indirect y, undocumented
+                0xf3 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*ISB (${:02x}),Y", self.temp2);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*RLA ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp2 = self.memory_cycle_read(
+                            self.temp2.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.subcycle = 6;
+                    }
+                    6 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 7;
+                    }
+                    _ => {
+                        self.temp = self.temp.wrapping_add(1);
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.cpu_sbc(self.temp);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //isb zero page x, undocumented
+                0xf7 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*ISB ${:02x},X", self.temp2);
+                            self.done_fetching = true;
+                        }
+                        self.temp2 = self.temp2.wrapping_add(self.x);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.temp.wrapping_add(1);
+                        self.memory_cycle_write(self.temp2 as u16, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.cpu_sbc(self.temp);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //isb absolute y, undocumented
+                0xfb => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*ISB ${:04x},Y", temp);
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.temp = self.temp.wrapping_add(1);
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.cpu_sbc(self.temp);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //isb absolute x, undocumented
+                0xff => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*ISB ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            if old_carry {
-                                self.temp |= 0x1;
-                            }
-                            self.a = self.a & self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 5;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.temp = self.temp.wrapping_add(1);
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.cpu_sbc(self.temp);
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //slo shift left, then or with accumulator, undocumented
+                //indirect x
+                0x03 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*SLO (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.tempaddr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.subcycle = 6;
+                    }
+                    6 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 7;
+                    }
+                    _ => {
+                        self.p &= !(CPU_FLAG_NEGATIVE | CPU_FLAG_ZERO | CPU_FLAG_CARRY);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                    },
-                    //rla indirect y
-                    0x33 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*RLA (${:02x}),Y", self.temp2);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        self.temp <<= 1;
+                        self.a |= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            self.temp2 = self.memory_cycle_read(
-                                self.temp2.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //slo zero page, undocumented
+                0x07 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*SLO ${:02x}", self.temp2);
+                            self.done_fetching = true;
                         }
-                        4 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 5;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.p &= !(CPU_FLAG_NEGATIVE | CPU_FLAG_ZERO | CPU_FLAG_CARRY);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        5 => {
-                            self.subcycle = 6;
+                        self.temp <<= 1;
+                        self.memory_cycle_write(self.temp2 as u16, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    _ => {
+                        self.a |= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
+                        }
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
+                        }
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //slo absolute, undocumented
+                0x0f => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*SLO ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        6 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.subcycle = 7;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_NEGATIVE | CPU_FLAG_ZERO | CPU_FLAG_CARRY);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        _ => {
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            if old_carry {
-                                self.temp |= 0x1;
-                            }
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.a = self.a & self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.temp <<= 1;
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.a |= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                    },
-                    //rla zero page x, undocumented
-                    0x37 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*RLA ${:02x},X", self.temp2);
-                                self.done_fetching = true;
-                            }
-                            self.temp2 = self.temp2.wrapping_add(self.x);
-                            self.subcycle = 2;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //slo indirect y, undocumented
+                0x13 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*SLO (${:02x}),Y", self.temp2);
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            if old_carry {
-                                self.temp |= 0x1;
-                            }
-                            self.memory_cycle_write(
-                                self.temp2 as u16,
-                                self.temp,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.a = self.a & self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 4;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp2 = self.memory_cycle_read(
+                            self.temp2.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.subcycle = 6;
+                    }
+                    6 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 7;
+                    }
+                    _ => {
+                        self.p &= !(CPU_FLAG_NEGATIVE | CPU_FLAG_ZERO | CPU_FLAG_CARRY);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        self.temp <<= 1;
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.a |= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                    },
-                    //rla absolute y, undocumented
-                    0x3b => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //slo zero page x, undocumented
+                0x17 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*SLO ${:02x},X", self.temp2);
+                            self.done_fetching = true;
+                        }
+                        self.temp2 = self.temp2.wrapping_add(self.x);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.p &= !(CPU_FLAG_NEGATIVE | CPU_FLAG_ZERO | CPU_FLAG_CARRY);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*RLA ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.temp <<= 1;
+                        self.memory_cycle_write(self.temp2 as u16, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.a |= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //slo absolute y, undocumented
+                0x1b => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*SLO ${:04x},Y", temp);
+                            self.done_fetching = true;
                         }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            if old_carry {
-                                self.temp |= 0x1;
-                            }
-                            self.subcycle = 6;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_NEGATIVE | CPU_FLAG_ZERO | CPU_FLAG_CARRY);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.a = self.a & self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        self.temp <<= 1;
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.a |= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                    },
-                    //rla absolute x, undocumented
-                    0x3f => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*RLA ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //slo absolute x, undocumented
+                0x1f => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*SLO ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_NEGATIVE | CPU_FLAG_ZERO | CPU_FLAG_CARRY);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        self.temp <<= 1;
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.a |= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x80) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp << 1;
-                            if old_carry {
-                                self.temp |= 0x1;
-                            }
-                            self.a = self.a & self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 6;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //rla, rotate left, then and with accumulator, undocumented
+                //indirect x
+                0x23 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*RLA (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //sre, shift right, then xor with accumulator, undocumented
-                    //indirect x
-                    0x43 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*SRE (${:02x},X)", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.tempaddr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.subcycle = 6;
+                    }
+                    6 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        2 => {
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.temp <<= 1;
+                        if old_carry {
+                            self.temp |= 0x1;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        self.a &= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        4 => {
-                            self.tempaddr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 5;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        5 => {
-                            self.subcycle = 6;
+                        self.subcycle = 7;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //rla zero page, undocumented
+                0x27 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*RLA ${:02x}", self.temp2);
+                            self.done_fetching = true;
                         }
-                        6 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            self.a = self.a ^ self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 7;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.temp <<= 1;
+                        if old_carry {
+                            self.temp |= 0x1;
                         }
-                    },
-                    //sre zero page, undocumented
-                    0x47 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*SRE ${:02x}", self.temp2);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        self.memory_cycle_write(self.temp2 as u16, self.temp, bus, cpu_peripherals);
+                        self.a &= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            self.memory_cycle_write(
-                                self.temp2 as u16,
-                                self.temp,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.a = self.a ^ self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 7;
+                        self.subcycle = 4;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //rla absolute, undocumented
+                0x2f => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*RLA ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                    },
-                    //sre absolute, undocumented
-                    0x4f => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.temp <<= 1;
+                        if old_carry {
+                            self.temp |= 0x1;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*SRE ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.a &= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            self.a = self.a ^ self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 5;
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //rla indirect y
+                0x33 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*RLA (${:02x}),Y", self.temp2);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp2 = self.memory_cycle_read(
+                            self.temp2.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.subcycle = 6;
+                    }
+                    6 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 7;
+                    }
+                    _ => {
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                    },
-                    //sre indirect y, undocumented
-                    0x53 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*SRE (${:02x}),Y", self.temp2);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        self.temp <<= 1;
+                        if old_carry {
+                            self.temp |= 0x1;
                         }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.a &= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        3 => {
-                            self.temp2 = self.memory_cycle_read(
-                                self.temp2.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        4 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 5;
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //rla zero page x, undocumented
+                0x37 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*RLA ${:02x},X", self.temp2);
+                            self.done_fetching = true;
+                        }
+                        self.temp2 = self.temp2.wrapping_add(self.x);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        5 => {
-                            self.subcycle = 6;
+                        self.temp <<= 1;
+                        if old_carry {
+                            self.temp |= 0x1;
                         }
-                        6 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.subcycle = 7;
+                        self.memory_cycle_write(self.temp2 as u16, self.temp, bus, cpu_peripherals);
+                        self.a &= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        _ => {
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.a = self.a ^ self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                    },
-                    //sre zero page x, undocumented
-                    0x57 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*SRE ${:02x},X", self.temp2);
-                                self.done_fetching = true;
-                            }
-                            self.temp2 = self.temp2.wrapping_add(self.x);
-                            self.subcycle = 2;
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //rla absolute y, undocumented
+                0x3b => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*RLA ${:04x},Y", temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            self.memory_cycle_write(
-                                self.temp2 as u16,
-                                self.temp,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.a = self.a ^ self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 4;
+                        self.temp <<= 1;
+                        if old_carry {
+                            self.temp |= 0x1;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.a &= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                    },
-                    //sre absolute y, undocumented
-                    0x5b => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //rla absolute x, undocumented
+                0x3f => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*RLA ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*SRE ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x80) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        self.temp <<= 1;
+                        if old_carry {
+                            self.temp |= 0x1;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        self.a &= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            self.subcycle = 6;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.a = self.a ^ self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //sre, shift right, then xor with accumulator, undocumented
+                //indirect x
+                0x43 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*SRE (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                    },
-                    //sre absolute x, undocumented
-                    0x5f => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.tempaddr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.subcycle = 6;
+                    }
+                    6 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*SRE ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.temp >>= 1;
+                        self.a ^= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        self.subcycle = 7;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //sre zero page, undocumented
+                0x47 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*SRE ${:02x}", self.temp2);
+                            self.done_fetching = true;
                         }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-
-                            self.a = self.a ^ self.temp;
-                            if self.a == 0 {
-                                self.p |= CPU_FLAG_ZERO;
-                            }
-                            if (self.a & 0x80) != 0 {
-                                self.p |= CPU_FLAG_NEGATIVE;
-                            }
-                            self.subcycle = 6;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        self.temp >>= 1;
+                        self.memory_cycle_write(self.temp2 as u16, self.temp, bus, cpu_peripherals);
+                        self.a ^= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                    },
-                    //rra, rotate right, then and with accumulator, undocumented
-                    //indirect x
-                    0x63 => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*RRA (${:02x},X)", self.temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        2 => {
-                            self.temp = self.temp.wrapping_add(self.x);
-                            self.temp2 =
-                                self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.subcycle = 7;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //sre absolute, undocumented
+                0x4f => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*SRE ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            self.temp = self.memory_cycle_read(
-                                self.temp.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        4 => {
-                            self.tempaddr = (self.temp as u16) << 8 | (self.temp2 as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 5;
+                        self.temp >>= 1;
+                        self.a ^= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        5 => {
-                            self.subcycle = 6;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        6 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            if old_carry {
-                                self.temp |= 0x80;
-                            }
-                            self.cpu_adc(self.temp);
-                            self.subcycle = 7;
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //sre indirect y, undocumented
+                0x53 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*SRE (${:02x}),Y", self.temp2);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp2 = self.memory_cycle_read(
+                            self.temp2.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.subcycle = 6;
+                    }
+                    6 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 7;
+                    }
+                    _ => {
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                    },
-                    //rra zero page, undocumented
-                    0x67 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*RRA ${:02x}", self.temp2);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        self.temp >>= 1;
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.a ^= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        3 => {
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            if old_carry {
-                                self.temp |= 0x80;
-                            }
-                            self.memory_cycle_write(
-                                self.temp2 as u16,
-                                self.temp,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.cpu_adc(self.temp);
-                            self.subcycle = 4;
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //sre zero page x, undocumented
+                0x57 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*SRE ${:02x},X", self.temp2);
+                            self.done_fetching = true;
+                        }
+                        self.temp2 = self.temp2.wrapping_add(self.x);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.temp >>= 1;
+                        self.memory_cycle_write(self.temp2 as u16, self.temp, bus, cpu_peripherals);
+                        self.a ^= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                    },
-                    //rra absolute, undocumented
-                    0x6f => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*RRA ${:04x}", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //sre absolute y, undocumented
+                0x5b => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*SRE ${:04x},Y", temp);
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        4 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            if old_carry {
-                                self.temp |= 0x80;
-                            }
-                            self.cpu_adc(self.temp);
-                            self.subcycle = 5;
+                        self.temp >>= 1;
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.a ^= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                    },
-                    //rra indirect y
-                    0x73 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*RRA (${:02x}),Y", self.temp2);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 2;
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //sre absolute x, undocumented
+                0x5f => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*SRE ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            self.temp2 = self.memory_cycle_read(
-                                self.temp2.wrapping_add(1) as u16,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.subcycle = 4;
+                        self.temp >>= 1;
+
+                        self.a ^= self.temp;
+                        if self.a == 0 {
+                            self.p |= CPU_FLAG_ZERO;
                         }
-                        4 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 5;
+                        if (self.a & 0x80) != 0 {
+                            self.p |= CPU_FLAG_NEGATIVE;
                         }
-                        5 => {
-                            self.subcycle = 6;
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //rra, rotate right, then and with accumulator, undocumented
+                //indirect x
+                0x63 => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*RRA (${:02x},X)", self.temp);
+                            self.done_fetching = true;
                         }
-                        6 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.subcycle = 7;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.temp.wrapping_add(self.x);
+                        self.temp2 = self.memory_cycle_read(self.temp as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp = self.memory_cycle_read(
+                            self.temp.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.tempaddr = (self.temp as u16) << 8 | (self.temp2 as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.subcycle = 6;
+                    }
+                    6 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        _ => {
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            if old_carry {
-                                self.temp |= 0x80;
-                            }
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.cpu_adc(self.temp);
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.temp >>= 1;
+                        if old_carry {
+                            self.temp |= 0x80;
                         }
-                    },
-                    //rra zero page x, undocumented
-                    0x77 => match self.subcycle {
-                        1 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                self.disassembly = format!("*RRA ${:02x},X", self.temp2);
-                                self.done_fetching = true;
-                            }
-                            self.temp2 = self.temp2.wrapping_add(self.x);
-                            self.subcycle = 2;
+                        self.cpu_adc(self.temp);
+                        self.subcycle = 7;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //rra zero page, undocumented
+                0x67 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*RRA ${:02x}", self.temp2);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp =
-                                self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
-                            self.subcycle = 3;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            if old_carry {
-                                self.temp |= 0x80;
-                            }
-                            self.memory_cycle_write(
-                                self.temp2 as u16,
-                                self.temp,
-                                bus,
-                                cpu_peripherals,
-                            );
-                            self.cpu_adc(self.temp);
-                            self.subcycle = 4;
+                        self.temp >>= 1;
+                        if old_carry {
+                            self.temp |= 0x80;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        self.memory_cycle_write(self.temp2 as u16, self.temp, bus, cpu_peripherals);
+                        self.cpu_adc(self.temp);
+                        self.subcycle = 4;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //rra absolute, undocumented
+                0x6f => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*RRA ${:04x}", temp);
+                            self.done_fetching = true;
                         }
-                        _ => {
-                            self.pc = self.pc.wrapping_add(2);
-                            self.end_instruction();
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                    },
-                    //rra absolute y, undocumented
-                    0x7b => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.temp >>= 1;
+                        if old_carry {
+                            self.temp |= 0x80;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*RRA ${:04x},Y", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.cpu_adc(self.temp);
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //rra indirect y
+                0x73 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*RRA (${:02x}),Y", self.temp2);
+                            self.done_fetching = true;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.temp2 = self.memory_cycle_read(
+                            self.temp2.wrapping_add(1) as u16,
+                            bus,
+                            cpu_peripherals,
+                        );
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.subcycle = 6;
+                    }
+                    6 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.subcycle = 7;
+                    }
+                    _ => {
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        self.temp >>= 1;
+                        if old_carry {
+                            self.temp |= 0x80;
                         }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            if old_carry {
-                                self.temp |= 0x80;
-                            }
-                            self.subcycle = 6;
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.cpu_adc(self.temp);
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //rra zero page x, undocumented
+                0x77 => match self.subcycle {
+                    1 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            self.disassembly = format!("*RRA ${:02x},X", self.temp2);
+                            self.done_fetching = true;
+                        }
+                        self.temp2 = self.temp2.wrapping_add(self.x);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp = self.memory_cycle_read(self.temp2 as u16, bus, cpu_peripherals);
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.cpu_adc(self.temp);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        self.temp >>= 1;
+                        if old_carry {
+                            self.temp |= 0x80;
                         }
-                    },
-                    //rra absolute x, undocumented
-                    0x7f => match self.subcycle {
-                        1 => {
-                            self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
-                            self.subcycle = 2;
+                        self.memory_cycle_write(self.temp2 as u16, self.temp, bus, cpu_peripherals);
+                        self.cpu_adc(self.temp);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    _ => {
+                        self.pc = self.pc.wrapping_add(2);
+                        self.end_instruction();
+                    }
+                },
+                //rra absolute y, undocumented
+                0x7b => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*RRA ${:04x},Y", temp);
+                            self.done_fetching = true;
                         }
-                        2 => {
-                            self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
-                            #[cfg(debug_assertions)]
-                            {
-                                let temp = (self.temp2 as u16) << 8 | self.temp as u16;
-                                self.disassembly = format!("*RRA ${:04x},X", temp);
-                                self.done_fetching = true;
-                            }
-                            self.subcycle = 3;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.y as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        3 => {
-                            self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
-                            self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
-                            self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
-                            self.subcycle = 4;
+                        self.temp >>= 1;
+                        if old_carry {
+                            self.temp |= 0x80;
                         }
-                        4 => {
-                            self.subcycle = 5;
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.cpu_adc(self.temp);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                //rra absolute x, undocumented
+                0x7f => match self.subcycle {
+                    1 => {
+                        self.temp = self.memory_cycle_read(self.pc + 1, bus, cpu_peripherals);
+                        self.subcycle = 2;
+                    }
+                    2 => {
+                        self.temp2 = self.memory_cycle_read(self.pc + 2, bus, cpu_peripherals);
+                        #[cfg(debug_assertions)]
+                        {
+                            let temp = (self.temp2 as u16) << 8 | self.temp as u16;
+                            self.disassembly = format!("*RRA ${:04x},X", temp);
+                            self.done_fetching = true;
                         }
-                        5 => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
-                            self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
-                            if (self.temp & 0x1) != 0 {
-                                self.p |= CPU_FLAG_CARRY;
-                            }
-                            self.temp = self.temp >> 1;
-                            if old_carry {
-                                self.temp |= 0x80;
-                            }
-                            self.cpu_adc(self.temp);
-                            self.subcycle = 6;
+                        self.subcycle = 3;
+                    }
+                    3 => {
+                        self.tempaddr = (self.temp2 as u16) << 8 | (self.temp as u16);
+                        self.tempaddr = self.tempaddr.wrapping_add(self.x as u16);
+                        self.temp = self.memory_cycle_read(self.tempaddr, bus, cpu_peripherals);
+                        self.subcycle = 4;
+                    }
+                    4 => {
+                        self.subcycle = 5;
+                    }
+                    5 => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        let old_carry = (self.p & CPU_FLAG_CARRY) != 0;
+                        self.p &= !(CPU_FLAG_CARRY | CPU_FLAG_ZERO | CPU_FLAG_NEGATIVE);
+                        if (self.temp & 0x1) != 0 {
+                            self.p |= CPU_FLAG_CARRY;
                         }
-                        _ => {
-                            self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
-                            self.pc = self.pc.wrapping_add(3);
-                            self.end_instruction();
+                        self.temp >>= 1;
+                        if old_carry {
+                            self.temp |= 0x80;
                         }
-                    },
-                    _ => {}
-                }
+                        self.cpu_adc(self.temp);
+                        self.subcycle = 6;
+                    }
+                    _ => {
+                        self.memory_cycle_write(self.tempaddr, self.temp, bus, cpu_peripherals);
+                        self.pc = self.pc.wrapping_add(3);
+                        self.end_instruction();
+                    }
+                },
+                _ => {}
             }
         }
     }
diff --git a/nes/rust/src/emulator_data.rs b/nes/rust/src/emulator_data.rs
index 530e23e..8fcde46 100644
--- a/nes/rust/src/emulator_data.rs
+++ b/nes/rust/src/emulator_data.rs
@@ -1,34 +1,53 @@
+//! This is the main implementation of the nes emulator. It provides most of the functionality of the emulator.
+
 use crate::{
     apu::NesApu,
     cartridge::NesCartridge,
     cpu::{NesCpu, NesCpuPeripherals},
     motherboard::NesMotherboard,
     ppu::NesPpu,
+    romlist::RomList,
 };
 
 #[cfg(feature = "eframe")]
 use eframe::egui;
 
+/// The main struct for the nes emulator.
 #[non_exhaustive]
 #[derive(serde::Serialize, serde::Deserialize)]
 pub struct NesEmulatorData {
+    /// The 6502 cpu
     pub cpu: NesCpu,
+    /// The peripherals of the cpu for the emulator
     pub cpu_peripherals: NesCpuPeripherals,
+    /// The motherboard for the emualtor
     pub mb: NesMotherboard,
+    /// Used for operating the cpu clock divider
     pub cpu_clock_counter: u8,
+    /// Used for operating the ppu clock divider
     ppu_clock_counter: u8,
+    /// Indicates that the emulator is paused.
     #[cfg(debug_assertions)]
     pub paused: bool,
+    /// Indicates that the cpu should be single stepped, used for debugging
     #[cfg(debug_assertions)]
     pub single_step: bool,
+    /// Used for debugging, to indicate to run to the end of the current frame, then pause.
     #[cfg(debug_assertions)]
     pub wait_for_frame_end: bool,
+    /// Used for frame timing
     pub last_frame_time: u128,
+    /// Used for emulating the proper behavior of the cpu for the nmi interrupt
+    #[cfg(any(feature = "eframe", feature = "egui-multiwin"))]
     nmi: [bool; 3],
+    /// Used for triggering the cpu irq line
     prev_irq: bool,
+    /// The list of roms for the emulator
+    pub roms: RomList,
 }
 
 impl NesEmulatorData {
+    /// Create a new nes emulator
     pub fn new() -> Self {
         let mb: NesMotherboard = NesMotherboard::new();
         let ppu = NesPpu::new();
@@ -37,7 +56,7 @@ impl NesEmulatorData {
         Self {
             cpu: NesCpu::new(),
             cpu_peripherals: NesCpuPeripherals::new(ppu, apu),
-            mb: mb,
+            mb,
             #[cfg(debug_assertions)]
             paused: false,
             #[cfg(debug_assertions)]
@@ -52,13 +71,16 @@ impl NesEmulatorData {
                 .as_millis(),
             nmi: [false; 3],
             prev_irq: false,
+            roms: RomList::load_list(),
         }
     }
 
+    /// serialize the structure, returning the raw data
     pub fn serialize(&self) -> Vec<u8> {
         bincode::serialize(&self).unwrap()
     }
 
+    /// deserialize the structure from the given data
     pub fn deserialize(&mut self, data: Vec<u8>) -> Result<(), Box<bincode::ErrorKind>> {
         match bincode::deserialize::<Self>(&data) {
             Ok(r) => {
@@ -69,24 +91,29 @@ impl NesEmulatorData {
         }
     }
 
+    /// Reset the cpu, ppu, and apu.
     pub fn reset(&mut self) {
         self.cpu.reset();
         self.cpu_peripherals.ppu_reset();
         self.cpu_peripherals.apu.reset();
     }
 
+    /// Remove a cartridge from the motherboard, throwing it away.
     pub fn remove_cartridge(&mut self) {
         self.mb.remove_cartridge();
     }
 
+    /// Insert a cartridge into the motherboard.
     pub fn insert_cartridge(&mut self, cart: NesCartridge) {
         self.mb.insert_cartridge(cart);
     }
 
+    /// Run a cycle for the ppu
     pub fn ppu_step(&mut self) {
         self.cpu_peripherals.ppu_cycle(&mut self.mb);
     }
 
+    /// Run a single cycle of the cpu and ppu system, dividing the input as necessary
     pub fn cycle_step(
         &mut self,
         sound: &mut Option<rb::Producer<f32>>,
@@ -102,7 +129,7 @@ impl NesEmulatorData {
             self.cpu
                 .cycle(&mut self.mb, &mut self.cpu_peripherals, nmi, self.prev_irq);
             self.prev_irq = irq;
-            self.cpu_peripherals.apu.clock_slow(sound, filter); //TODO replace with filter
+            self.cpu_peripherals.apu.clock_slow(sound, filter);
         }
 
         self.ppu_clock_counter += 1;
diff --git a/nes/rust/src/main.rs b/nes/rust/src/main.rs
index 9ee830a..547696e 100644
--- a/nes/rust/src/main.rs
+++ b/nes/rust/src/main.rs
@@ -1,14 +1,19 @@
 #![cfg_attr(not(debug_assertions), windows_subsystem = "windows")] // hide console window on Windows in release
-
-pub mod apu;
-pub mod cartridge;
-pub mod controller;
-pub mod cpu;
-pub mod emulator_data;
-pub mod motherboard;
-pub mod ppu;
-pub mod romlist;
-pub mod utility;
+#![deny(missing_docs)]
+#![deny(clippy::missing_docs_in_private_items)]
+
+//! This is the nes emulator written in rust. It is compatible with windows, linux, and osx.
+
+mod apu;
+mod cartridge;
+mod controller;
+mod cpu;
+mod emulator_data;
+mod motherboard;
+mod ppu;
+mod romlist;
+#[cfg(test)]
+mod utility;
 
 use std::io::Write;
 
@@ -22,10 +27,7 @@ mod tests;
 use crate::cartridge::NesCartridge;
 use crate::ppu::NesPpu;
 
-//const INITIAL_ROM : Option<&str> = None;
-
-//const INITIAL_ROM : Option<&str> = Some("./nes/test_roms/sprite_overflow_tests/5.Emulator.nes");
-//const INITIAL_ROM: Option<&str> = Some("./nes/test_roms/sprite_overflow_tests/2.Details.nes");
+/// The initial rom that the emulator will load. Only for developmment of the beta version (0.1.x)
 const INITIAL_ROM: Option<&str> = Some("./nes/test_roms/read_joy3/test_buttons.nes");
 //const INITIAL_ROM: Option<&str> = Some("./nes/roms/USA/Spelunker (U) [!].nes");
 
@@ -62,17 +64,26 @@ use sdl2::render::TextureCreator;
 #[cfg(feature = "sdl2")]
 pub const EMBEDDED_FONT: &[u8] = include_bytes!("cmsltt10.ttf");
 
+/// The struct for the main window of the emulator.
 struct MainNesWindow {
+    /// The time of the last emulated frame for the emulator. Even if the emulator is paused, the screen will still run at the proper frame rate.
     last_frame_time: std::time::SystemTime,
     #[cfg(feature = "eframe")]
     c: NesEmulatorData,
+    /// The calculated frames per second performance of the emulator.
     fps: f64,
+    /// The number of samples per second of the audio output.
     sound_rate: u32,
+    /// The producing half of the ring buffer used for audio.
     sound: Option<rb::Producer<f32>>,
+    /// The texture used for rendering the ppu image.
     #[cfg(any(feature = "eframe", feature = "egui-multiwin"))]
     pub texture: Option<egui::TextureHandle>,
+    /// The filter used for audio playback, filtering out high frequency noise, increasing the quality of audio playback.
     filter: Option<biquad::DirectForm1<f32>>,
+    /// The interval between sound samples based on the sample rate used in the stream
     sound_sample_interval: f32,
+    /// The stream used for audio playback during emulation
     sound_stream: Option<cpal::Stream>,
 }
 
@@ -91,8 +102,10 @@ impl MainNesWindow {
             fps: 0.0,
         }
     }
+
+    /// Create a new request for a main window of the emulator.
     #[cfg(feature = "egui-multiwin")]
-    fn new(
+    fn new_request(
         rate: u32,
         producer: Option<rb::Producer<f32>>,
         stream: Option<cpal::Stream>,
@@ -260,12 +273,10 @@ impl TrackedWindow for MainNesWindow {
             {
                 if !c.paused {
                     c.cycle_step(&mut self.sound, &mut self.filter);
-                    if c.cpu_clock_counter == 0 && c.cpu.breakpoint_option() {
-                        if c.single_step {
-                            c.paused = true;
-                            c.single_step = false;
-                            break 'emulator_loop;
-                        }
+                    if c.cpu_clock_counter == 0 && c.cpu.breakpoint_option() && c.single_step {
+                        c.paused = true;
+                        c.single_step = false;
+                        break 'emulator_loop;
                     }
                 } else {
                     break 'emulator_loop;
@@ -289,7 +300,7 @@ impl TrackedWindow for MainNesWindow {
 
         let image = NesPpu::convert_to_egui(c.cpu_peripherals.ppu_get_frame());
 
-        if let None = self.texture {
+        if self.texture.is_none() {
             self.texture = Some(egui.egui_ctx.load_texture(
                 "NES_PPU",
                 image,
@@ -307,7 +318,7 @@ impl TrackedWindow for MainNesWindow {
                 ui.menu_button("File", |ui| {
                     let button = egui_multiwin::egui::Button::new("Open rom?");
                     if ui.add_enabled(true, button).clicked() {
-                        windows_to_create.push(RomFinder::new());
+                        windows_to_create.push(RomFinder::new_request());
                         ui.close_menu();
                     }
 
@@ -339,7 +350,7 @@ impl TrackedWindow for MainNesWindow {
                     ui.menu_button("Debug", |ui| {
                         if ui.button("Debugger").clicked() {
                             ui.close_menu();
-                            windows_to_create.push(DebugNesWindow::new());
+                            windows_to_create.push(DebugNesWindow::new_request());
                         }
                         if ui.button("Reset").clicked() {
                             ui.close_menu();
@@ -378,7 +389,7 @@ impl TrackedWindow for MainNesWindow {
 
         if load_state {
             if let Ok(a) = std::fs::read("./state.bin") {
-                c.deserialize(a);
+                let _e = c.deserialize(a);
             }
         }
 
@@ -407,18 +418,20 @@ impl TrackedWindow for MainNesWindow {
         self.last_frame_time = new_frame_time;
 
         RedrawResponse {
-            quit: quit,
+            quit,
             new_windows: windows_to_create,
         }
     }
 }
 
+/// The structure for a debug window of the emulator.
 #[cfg(feature = "egui-multiwin")]
 struct DebugNesWindow {}
 
 #[cfg(feature = "egui-multiwin")]
 impl DebugNesWindow {
-    fn new() -> NewWindowRequest<NesEmulatorData> {
+    /// Create a new request for a Debug window.
+    fn new_request() -> NewWindowRequest<NesEmulatorData> {
         NewWindowRequest {
             window_state: Box::new(DebugNesWindow {}),
             builder: egui_multiwin::glutin::window::WindowBuilder::new()
@@ -472,10 +485,8 @@ impl TrackedWindow for DebugNesWindow {
                         c.wait_for_frame_end = true;
                         c.paused = false;
                     }
-                } else {
-                    if ui.button("Pause").clicked() {
-                        c.single_step = true;
-                    }
+                } else if ui.button("Pause").clicked() {
+                    c.single_step = true;
                 }
                 ui.horizontal(|ui| {
                     ui.label(format!("Address: 0x{:x}", c.cpu.get_pc()));
@@ -498,20 +509,23 @@ impl TrackedWindow for DebugNesWindow {
             }
         });
         RedrawResponse {
-            quit: quit,
+            quit,
             new_windows: windows_to_create,
         }
     }
 }
 
+/// The structure for a window that helps a user select a rom to load.
 #[cfg(feature = "egui-multiwin")]
 struct RomFinder {
+    /// The element responsible for parsing the list of roms known by the emulator.
     parser: romlist::RomListParser,
 }
 
 #[cfg(feature = "egui-multiwin")]
 impl RomFinder {
-    fn new() -> NewWindowRequest<NesEmulatorData> {
+    /// Create a new request to make a RomFinder window.
+    fn new_request() -> NewWindowRequest<NesEmulatorData> {
         NewWindowRequest {
             window_state: Box::new(RomFinder {
                 parser: romlist::RomListParser::new(),
@@ -559,20 +573,18 @@ impl TrackedWindow for RomFinder {
                 let mut new_rom = None;
                 for (p, entry) in self.parser.list().elements.iter() {
                     if let Some(r) = &entry.result {
-                        if r.is_ok() {
-                            if ui
+                        if r.is_ok()
+                            && ui
                                 .add(
                                     egui_multiwin::egui::Label::new(format!("{}", p.display()))
                                         .sense(Sense::click()),
                                 )
                                 .double_clicked()
-                            {
-                                new_rom = Some(
-                                    NesCartridge::load_cartridge(p.to_str().unwrap().into())
-                                        .unwrap(),
-                                );
-                                quit = true;
-                            }
+                        {
+                            new_rom = Some(
+                                NesCartridge::load_cartridge(p.to_str().unwrap().into()).unwrap(),
+                            );
+                            quit = true;
                         }
                     }
                 }
@@ -585,7 +597,7 @@ impl TrackedWindow for RomFinder {
         });
 
         RedrawResponse {
-            quit: quit,
+            quit,
             new_windows: windows_to_create,
         }
     }
@@ -844,7 +856,7 @@ fn main() {
         None
     };
 
-    let root_window = MainNesWindow::new(sound_rate, sound_producer, sound_stream);
+    let root_window = MainNesWindow::new_request(sound_rate, sound_producer, sound_stream);
 
     let wdir = std::env::current_dir().unwrap();
     println!("Current dir is {}", wdir.display());
@@ -859,7 +871,7 @@ fn main() {
     #[cfg(debug_assertions)]
     {
         if nes_data.paused {
-            let debug_win = DebugNesWindow::new();
+            let debug_win = DebugNesWindow::new_request();
             let _e = multi_window.add(debug_win, &event_loop);
         }
     }
diff --git a/nes/rust/src/motherboard.rs b/nes/rust/src/motherboard.rs
index 3267ced..6f72fc1 100644
--- a/nes/rust/src/motherboard.rs
+++ b/nes/rust/src/motherboard.rs
@@ -1,25 +1,37 @@
+//! This module handles all of the wiring and memory for the nes system.
+
 use crate::controller::NesController;
 use crate::controller::NesControllerTrait;
 use crate::{cartridge::NesCartridge, cpu::NesCpuPeripherals};
 use serde_with::Bytes;
 
+/// A struct for the nes motherboard, containing accessories to the main chips.
 #[non_exhaustive]
 #[serde_with::serde_as]
 #[derive(serde::Serialize, serde::Deserialize)]
 pub struct NesMotherboard {
+    /// The cartridge to use in the system
     cart: Option<NesCartridge>,
+    /// The cpu ram
     #[serde_as(as = "Bytes")]
     ram: [u8; 2048],
+    /// The ppu vram, physically outside the ppu, so this makes perfect sense.
     #[serde_as(as = "Bytes")]
     vram: [u8; 2048],
+    /// The palette ram for the ppu, technically belongs in the ppu.
     ppu_palette_ram: [u8; 32],
+    /// The vram address fromm the last ppu address cycle
     vram_address: Option<u16>,
+    /// Used for detecting sequence problems in the ppu
     last_ppu_cycle: u8,
+    /// Used for open bus implementation of the cpu memory bus
     last_cpu_data: u8,
+    /// The controllers for the system
     pub controllers: [Option<NesController>; 2],
 }
 
 impl NesMotherboard {
+    /// Create a new nes motherboard
     pub fn new() -> Self {
         //board ram is random on startup
         let mut main_ram: [u8; 2048] = [0; 2048];
@@ -39,7 +51,7 @@ impl NesMotherboard {
         Self {
             cart: None,
             ram: main_ram,
-            vram: vram,
+            vram,
             ppu_palette_ram: pram,
             vram_address: None,
             last_ppu_cycle: 2,
@@ -48,24 +60,29 @@ impl NesMotherboard {
         }
     }
 
+    /// Remove any cartridge that may exist in the system.
     pub fn remove_cartridge(&mut self) {
         self.cart = None;
     }
 
+    /// Insert a cartridge into the system, but only if one is not already present
     pub fn insert_cartridge(&mut self, c: NesCartridge) {
-        if let None = self.cart {
+        if self.cart.is_none() {
             self.cart = Some(c);
         }
     }
 
+    /// Insert a controller into the controller 1 port, removing any existing controller
     pub fn insert_controller1(&mut self, c: NesController) {
         self.controllers[0] = Some(c);
     }
 
+    /// Insert a controller into the controller 2 port, removing any existing controller
     pub fn insert_controller2(&mut self, c: NesController) {
         self.controllers[1] = Some(c);
     }
 
+    /// Used by testing code for automated testing.
     #[cfg(test)]
     pub fn check_vram(&self, addr: u16, check: &[u8]) -> bool {
         for (i, data) in check.iter().enumerate() {
@@ -76,6 +93,7 @@ impl NesMotherboard {
         return true;
     }
 
+    /// Perform a read operation on the cpu memory bus
     pub fn memory_cycle_read(
         &mut self,
         addr: u16,
@@ -174,6 +192,7 @@ impl NesMotherboard {
         response
     }
 
+    /// Perform a write operation on the cpu memory bus
     pub fn memory_cycle_write(
         &mut self,
         addr: u16,
@@ -249,6 +268,7 @@ impl NesMotherboard {
         }
     }
 
+    /// Perform the address part of a ppu memory cycle
     pub fn ppu_cycle_1(&mut self, addr: u16) {
         if self.last_ppu_cycle != 2 {
             println!("ERROR PPU CYCLING a");
@@ -257,7 +277,7 @@ impl NesMotherboard {
         if let Some(cart) = &mut self.cart {
             let (a10, vram_enable) = cart.ppu_cycle_1(addr);
             self.vram_address = if !vram_enable {
-                if addr >= 0x2000 && addr <= 0x3fff {
+                if (0x2000..=0x3fff).contains(&addr) {
                     Some(addr | ((a10 as u16) << 10))
                 } else {
                     None
@@ -268,6 +288,7 @@ impl NesMotherboard {
         }
     }
 
+    /// Perform the write portion of a ppu memory cycle
     pub fn ppu_cycle_2_write(&mut self, data: u8) {
         if self.last_ppu_cycle != 1 {
             println!("ERROR PPU CYCLING b");
@@ -292,13 +313,12 @@ impl NesMotherboard {
                 }
                 _ => {}
             }
-        } else {
-            if let Some(cart) = &mut self.cart {
-                cart.ppu_cycle_write(data);
-            }
+        } else if let Some(cart) = &mut self.cart {
+            cart.ppu_cycle_write(data);
         }
     }
 
+    /// Perform the read portion of a ppu memory cycle
     pub fn ppu_cycle_2_read(&mut self) -> u8 {
         if self.last_ppu_cycle != 1 {
             println!("ERROR PPU CYCLING c");
@@ -330,6 +350,7 @@ impl NesMotherboard {
         }
     }
 
+    /// Read a palette address
     pub fn ppu_palette_read(&self, addr: u16) -> u8 {
         let addr2: usize = (addr as usize) & 0x1f;
         self.ppu_palette_ram[addr2]
diff --git a/nes/rust/src/ppu.rs b/nes/rust/src/ppu.rs
index 84df5d0..6f64f8d 100644
--- a/nes/rust/src/ppu.rs
+++ b/nes/rust/src/ppu.rs
@@ -1,3 +1,5 @@
+//! The ppu module for the emulator. Responsible for emulating the chip that generates all of the graphics for the nes.
+
 use crate::motherboard::NesMotherboard;
 use serde_with::Bytes;
 
@@ -7,26 +9,38 @@ use eframe::egui;
 #[cfg(feature = "egui-multiwin")]
 use egui_multiwin::egui;
 
+/// The various modes of evaluating sprites for a scanline
 #[non_exhaustive]
 #[derive(serde::Serialize, serde::Deserialize)]
 enum PpuSpriteEvalMode {
+    /// Look for sprites on the current scanline
     Normal,
+    /// A sprite has been found, copy the other bytes of that sprite
     CopyCurrentSprite,
+    /// The are currently 8 sprites that have been found for the current scanline
     Sprites8,
+    /// Sprites are done being evaluated
     Done,
 }
 
+/// A struct for a single sprite of the ppu
 #[non_exhaustive]
 #[derive(serde::Serialize, serde::Deserialize, Copy, Clone, Debug)]
 pub struct PpuSprite {
+    /// The y coordinate for the sprite on screen
     y: u8,
+    /// The tile number for the sprite
     tile: u8,
+    /// The attribute data for the sprite
     attribute: u8,
+    /// The x coordinate of the sprite on screen
     x: u8,
+    /// The pattern table data for the sprite
     patterntable_data: u16,
 }
 
 impl PpuSprite {
+    /// Create a new sprite, off of the rendered screen
     fn new() -> Self {
         Self {
             y: 0xff,
@@ -37,16 +51,19 @@ impl PpuSprite {
         }
     }
 
+    /// Returns the pallete for the sprite
     pub fn pallete(&self) -> u16 {
         ((self.attribute & 3) as u16) << 2
     }
 
+    /// Returns the tile number to fetch for this sprite. Probably incorrect for tall sprites
     pub fn tile_num(&self, _scanline: u8) -> u16 {
-        let calc = (self.tile & 0xff) as u16;
+        let calc = self.tile as u16;
         let adder: u16 = 0;
         adder + calc * 0x10
     }
 
+    /// Returns the line number to render of the sprite, given the scanline being rendered
     pub fn line_number(&self, scanline: u8) -> u8 {
         if self.y <= scanline {
             let sprite_line = (scanline - self.y) % 8;
@@ -61,73 +78,118 @@ impl PpuSprite {
     }
 }
 
+/// The structure for the nes PPU (picture processing unit)
 #[non_exhaustive]
 #[serde_with::serde_as]
 #[derive(serde::Serialize, serde::Deserialize)]
 pub struct NesPpu {
+    /// The registers for the ppu
     registers: [u8; 8],
+    /// The index of the current rendering row
     scanline_number: u16,
+    /// The index of the current rendering column
     scanline_cycle: u16,
+    /// The flag that indicates the end of a frame has occurred. Used for synchronizing frame rate of the emulator.
     frame_end: bool,
+    /// Controls access to registers 5 and 6 for writes by the cpu
     address_bit: bool,
-    data_bit: bool,
+    /// Used for clearing the vblank flag
     vblank_clear: bool,
+    /// Flag used for generating irq signals used by the cpu.
     vblank_nmi: bool,
+    /// Indicates that an odd frame is currently being rendered.
     frame_odd: bool,
+    /// Used to ignore writes to certain registers during ppu startup. Used with PPU_STARTUP_CYCLE_COUNT
     write_ignore_counter: u16,
+    /// The data from the nametable, used for background fetching
     nametable_data: u8,
+    /// The attribute table data, used for background rendering
     attributetable_data: u8,
+    /// The shift register for the attribute table, used for background rendering
     attributetable_shift: [u8; 2],
+    /// The patterntable data, for displaying background data.
     patterntable_tile: u16,
+    /// The shift register for the patterntable, used for background rendering
     #[serde_as(as = "[_; 2]")]
     patterntable_shift: [u16; 2],
+    /// The frame data stored in the ppu for being displayed onto the screen later.
     #[serde_as(as = "Bytes")]
     frame_data: Box<[u8; 3 * 256 * 240]>,
+    /// Indicates that there is a pending write from the cpu
     pend_vram_write: Option<u8>,
+    /// Indicates that there is a pending read from the cpu
     pend_vram_read: Option<u16>,
+    /// The vram address for accessing ppu vram (different from oam)
     vram_address: u16,
+    /// The frame number of the ppu, used for testing and debugging purposes.
     #[cfg(any(test, debug_assertions))]
     frame_number: u64,
-    last_nmi: bool,
+    /// For read operations by the cpu
     ppudata_buffer: u8,
+    /// The data for emulating pen bus behavior
     last_cpu_data: u8,
+    /// The counter used for emulating open bus behavior of the ppu
     last_cpu_counter: [u32; 2],
     #[serde_as(as = "Bytes")]
+    /// The memory for holding up to 64 sprites for the entire frame.
     oam: [u8; 256],
+    /// The memory for storing evaluated sprites for the next scanline
     secondary_oam: [u8; 32],
+    /// The sprites for the current scanline being rendered
     sprites: [PpuSprite; 8],
+    /// The address to use for secondary oam access
     secondaryoamaddress: u8,
-    numsprites: u8,
+    /// The data retrieved from the oam
     oamdata: u8,
+    /// The address to use for oam access
     oamaddress: u8,
+    /// The mode for sprite evaluation in the sprite_eval function
     sprite_eval_mode: PpuSpriteEvalMode,
+    /// Indicates that the first half of the ppu memory cycle has been completed.
     cycle1_done: bool,
-    debug_special: bool,
+    /// The horizontal scroll amount, in pixels
     scrollx: u8,
+    /// The vertical scroll amount, in pixels
     scrolly: u8,
-    frame_scrolly: u8,
 }
 
+/// The flags that set the nametable base
 const PPU_REGISTER0_NAMETABLE_BASE: u8 = 0x03;
+/// The flag that sets the vram address increment amount
 const PPU_REGISTER0_VRAM_ADDRESS_INCREMENT: u8 = 0x04;
+/// The flag to select the sprite table base
 const PPU_REGISTER0_SPRITETABLE_BASE: u8 = 0x08;
+/// The flag that selects the second half of the pattern table for the background
 const PPU_REGISTER0_BACKGROUND_PATTERNTABLE_BASE: u8 = 0x10;
+/// The flag that indicates a larger sprite size of 16 pixels height instead of 8 pixels
 const PPU_REGISTER0_SPRITE_SIZE: u8 = 0x20;
+/// The flag that indicates that the nmi should be generated
 const PPU_REGISTER0_GENERATE_NMI: u8 = 0x80;
 
+/// The flag that indicates that everything should be in grayscale
 const PPU_REGISTER1_GREYSCALE: u8 = 0x01;
+/// The flag that indicates that the background should be drawn in the first column
 const PPU_REGISTER1_DRAW_BACKGROUND_FIRST_COLUMN: u8 = 0x02;
+/// The flag that indicates sprites should be drawn in the first column
 const PPU_REGISTER1_DRAW_SPRITES_FIRST_COLUMN: u8 = 0x04;
+/// The flag that indicates the background should be drawn
 const PPU_REGISTER1_DRAW_BACKGROUND: u8 = 0x08;
+/// The flag that indicates sprites should be drawn
 const PPU_REGISTER1_DRAW_SPRITES: u8 = 0x10;
+/// The flag for emphasizing the red channel
 const PPU_REGISTER1_EMPHASIZE_RED: u8 = 0x20;
+/// The flag for emphasizing the green channel
 const PPU_REGISTER1_EMPHASIZE_GREEN: u8 = 0x40;
+/// The flag for emphasizing the blue channel
 const PPU_REGISTER1_EMPHASIZE_BLUE: u8 = 0x80;
 
+/// The number of cycles where the ppu is in a special state on startup.
 const PPU_STARTUP_CYCLE_COUNT: u16 = 29658;
 
+/// The palette for the ppu
 const PPU_PALETTE: [[u8; 3]; 64] = palette_generator(); //TODO put in correct colors into the palette
 
+/// Build a palette for the ppu.
 const fn palette_generator() -> [[u8; 3]; 64] {
     let mut palette: [[u8; 3]; 64] = [[0; 3]; 64];
     palette[0] = [84, 84, 84];
@@ -201,6 +263,7 @@ const fn palette_generator() -> [[u8; 3]; 64] {
 }
 
 impl NesPpu {
+    /// Return a new ppu.
     pub fn new() -> Self {
         let reg2: u8 = rand::random::<u8>() & !0x40;
         let mut oam = [0; 256];
@@ -217,7 +280,6 @@ impl NesPpu {
             scanline_cycle: 0,
             registers: [0, 0, reg2, 0, 0, 0, 0, 0],
             address_bit: false,
-            data_bit: false,
             vblank_nmi: false,
             vblank_clear: false,
             frame_end: false,
@@ -234,31 +296,29 @@ impl NesPpu {
             vram_address: 0,
             #[cfg(any(test, debug_assertions))]
             frame_number: 0,
-            last_nmi: false,
             ppudata_buffer: 0,
             last_cpu_data: 0,
             last_cpu_counter: [0, 0],
-            oam: oam,
+            oam,
             secondary_oam: oam2,
             sprites: [PpuSprite::new(); 8],
             secondaryoamaddress: 0,
-            numsprites: 0,
             oamdata: 0,
             sprite_eval_mode: PpuSpriteEvalMode::Normal,
             oamaddress: 0,
             cycle1_done: false,
-            debug_special: false,
             scrollx: 0,
             scrolly: 0,
-            frame_scrolly: 0,
         }
     }
 
+    /// Return the frame number of the ppu, mostly used for testing and debugging the ppu
     #[cfg(any(test, debug_assertions))]
     pub fn frame_number(&self) -> u64 {
         self.frame_number
     }
 
+    /// Reset the ppu
     pub fn reset(&mut self) {
         self.registers[0] = 0;
         self.registers[1] = 0;
@@ -268,45 +328,47 @@ impl NesPpu {
         }
     }
 
+    /// Returns the vram address of the ppu
     pub fn vram_address(&self) -> u16 {
         self.vram_address
     }
 
+    /// Increment the vram address, ignoring any wrapping
     pub fn increment_vram(&mut self) {
         self.vram_address = self.vram_address.wrapping_add(1);
     }
 
+    /// Allows providing palette data directly to the ppu
     pub fn provide_palette_data(&mut self, data: u8) {
         let data2 = data & 0x3f;
         self.last_cpu_data = data2;
         self.last_cpu_counter[1] = 893420;
     }
 
+    /// Returns a copy of the sprites in the ppu memory
     #[cfg(any(test, debug_assertions))]
     pub fn get_64_sprites(&self) -> [PpuSprite; 64] {
         let mut s: [PpuSprite; 64] = [PpuSprite::new(); 64];
-        for i in 0..64 {
-            s[i].y = self.oam[i * 4];
-            s[i].tile = self.oam[1 + i * 4];
-            s[i].attribute = self.oam[2 + i * 4];
-            s[i].x = self.oam[3 + i * 4];
+        for (i, e) in s.iter_mut().enumerate() {
+            e.y = self.oam[i * 4];
+            e.tile = self.oam[1 + i * 4];
+            e.attribute = self.oam[2 + i * 4];
+            e.x = self.oam[3 + i * 4];
         }
         s
     }
 
+    /// Perform reads done by the cpu.
     pub fn read(&mut self, addr: u16) -> Option<u8> {
         match addr {
             0 | 1 | 3 | 5 | 6 => Some(self.last_cpu_data),
             4 => {
                 let mut data = self.oam[self.oamaddress as usize];
-                match self.oamaddress & 3 {
-                    2 => {
-                        data &= 0xe3;
-                        self.last_cpu_data = data;
-                        self.last_cpu_counter[0] = 893420;
-                        self.last_cpu_counter[1] = 893420;
-                    }
-                    _ => {}
+                if (self.oamaddress & 3) == 2 {
+                    data &= 0xe3;
+                    self.last_cpu_data = data;
+                    self.last_cpu_counter[0] = 893420;
+                    self.last_cpu_counter[1] = 893420;
                 }
                 Some(data)
             }
@@ -332,7 +394,6 @@ impl NesPpu {
                 let mut val = self.registers[addr as usize];
                 if addr == 2 {
                     self.address_bit = false;
-                    self.data_bit = false;
                     self.vblank_clear = true;
                     val = (val & 0xE0) | self.last_cpu_data & 0x1f;
                     self.last_cpu_data = (self.last_cpu_data & 0x1f) | (val & 0xE0);
@@ -343,6 +404,7 @@ impl NesPpu {
         }
     }
 
+    /// Perform writes done by the cpu.
     pub fn write(&mut self, addr: u16, data: u8) {
         self.last_cpu_data = data;
         self.last_cpu_counter[0] = 893420;
@@ -381,12 +443,11 @@ impl NesPpu {
                 self.oam[self.oamaddress as usize] = data;
                 self.oamaddress = self.oamaddress.wrapping_add(1);
             }
-            7 => match self.vram_address {
-                0..=0x3eff => {
+            7 => {
+                if let 0..=0x3eff = self.vram_address {
                     self.pend_vram_write = Some(data);
                 }
-                _ => {}
-            },
+            }
             2 => {}
             _ => {
                 self.registers[addr as usize] = data;
@@ -394,6 +455,7 @@ impl NesPpu {
         }
     }
 
+    /// This increments the scanline cycle machine, sweeping across every scanline, and down every row sequentially.
     fn increment_scanline_cycle(&mut self) {
         self.scanline_cycle += 1;
         if self.scanline_cycle == 341 {
@@ -415,16 +477,17 @@ impl NesPpu {
         }
     }
 
+    /// Calculates the base for the name table, taking into account x and y scrolling
     fn nametable_base(&self) -> u16 {
-        let base = match self.registers[0] & PPU_REGISTER0_NAMETABLE_BASE {
+        match self.registers[0] & PPU_REGISTER0_NAMETABLE_BASE {
             0 => 0x2000,
             1 => 0x2400,
             2 => 0x2800,
             _ => 0x2c00,
-        };
-        base
+        }
     }
 
+    /// Calculates the coordinates for the name table, taking into account x and y scrolling
     fn nametable_coordinates(&self, x: u8, y: u8) -> (u16, u8, u8) {
         let mut base = self.nametable_base();
         let (x, ox) = x.overflowing_add(self.scrollx);
@@ -438,16 +501,17 @@ impl NesPpu {
         (base, x, (y % 240) as u8)
     }
 
+    /// Calculates the base for the attribute table, taking into account x and y scrolling
     fn attributetable_base(&self) -> u16 {
-        let base = match self.registers[0] & PPU_REGISTER0_NAMETABLE_BASE {
+        match self.registers[0] & PPU_REGISTER0_NAMETABLE_BASE {
             0 => 0x23c0,
             1 => 0x27c0,
             2 => 0x2bc0,
             _ => 0x2fc0,
-        };
-        base
+        }
     }
 
+    /// Calculates the coordinates for the attribute table, taking into account x and y scrolling
     fn attributetable_coordinates(&self, x: u8, y: u8) -> (u16, u8, u8) {
         let mut base = self.attributetable_base();
         let (x, ox) = x.overflowing_add(self.scrollx);
@@ -461,6 +525,7 @@ impl NesPpu {
         (base, x, (y % 240) as u8)
     }
 
+    /// Returns the pattern table base for the sprites.
     fn sprite_patterntable_base(&self) -> u16 {
         if (self.registers[0] & PPU_REGISTER0_SPRITE_SIZE) != 0
             || (self.registers[0] & PPU_REGISTER0_SPRITETABLE_BASE) == 0
@@ -471,6 +536,7 @@ impl NesPpu {
         }
     }
 
+    /// Returns the pattern table base for the background.
     fn background_patterntable_base(&self) -> u16 {
         if (self.registers[0] & PPU_REGISTER0_BACKGROUND_PATTERNTABLE_BASE) == 0 {
             0
@@ -479,6 +545,7 @@ impl NesPpu {
         }
     }
 
+    /// Returns true when the background should be rendered.
     fn should_render_background(&self, cycle: u8) -> bool {
         if cycle < 8 {
             (self.registers[1] & PPU_REGISTER1_DRAW_BACKGROUND_FIRST_COLUMN) != 0
@@ -487,6 +554,7 @@ impl NesPpu {
         }
     }
 
+    /// Returns true when sprites should be rendered.
     fn should_render_sprites(&self, cycle: u8) -> bool {
         if cycle == 0 {
             (self.registers[1] & PPU_REGISTER1_DRAW_SPRITES_FIRST_COLUMN) != 0
@@ -495,6 +563,7 @@ impl NesPpu {
         }
     }
 
+    /// Computes the xy coordinates to be used by the background fetcher.
     fn compute_xy(&self, cycle: u8, offset: u8) -> (u8, u8) {
         let (cycle2, ox) = cycle.overflowing_add(offset);
         let mut scanline = self.scanline_number;
@@ -505,6 +574,7 @@ impl NesPpu {
         (cycle2, scanline as u8)
     }
 
+    /// Performs fetches for the background data of the ppu.
     fn background_fetch(&mut self, bus: &mut NesMotherboard, cycle: u8) {
         let (x, y) = self.compute_xy(cycle, 16);
         match (cycle / 2) % 4 {
@@ -537,8 +607,7 @@ impl NesPpu {
                 if (cycle & 1) == 0 {
                     let base = self.background_patterntable_base();
                     let offset = (self.nametable_data as u16) << 4;
-                    let calc =
-                        base + offset + ((self.scanline_number + self.scrolly as u16) % 8) as u16;
+                    let calc = base + offset + (self.scanline_number + self.scrolly as u16) % 8;
                     bus.ppu_cycle_1(calc);
                     self.cycle1_done = true;
                 } else if self.cycle1_done {
@@ -553,10 +622,7 @@ impl NesPpu {
                 if (cycle & 1) == 0 {
                     let base = self.background_patterntable_base();
                     let offset = (self.nametable_data as u16) << 4;
-                    let calc = 8
-                        + base
-                        + offset
-                        + ((self.scanline_number + self.scrolly as u16) % 8) as u16;
+                    let calc = 8 + base + offset + (self.scanline_number + self.scrolly as u16) % 8;
                     bus.ppu_cycle_1(calc);
                     self.cycle1_done = true;
                 } else if self.cycle1_done {
@@ -574,6 +640,7 @@ impl NesPpu {
         }
     }
 
+    /// Allows for cpu operations to read and write to ppu vram
     fn idle_operation(&mut self, bus: &mut NesMotherboard, cycle: u16) {
         if (cycle & 1) == 0 {
             if let Some(_a) = self.pend_vram_write {
@@ -601,6 +668,7 @@ impl NesPpu {
         }
     }
 
+    /// Returns the height of sprites, by examining the current configuration of the ppu
     fn sprite_height(&self) -> u8 {
         let big = (self.registers[0] & PPU_REGISTER0_SPRITE_SIZE) != 0;
         if big {
@@ -610,6 +678,8 @@ impl NesPpu {
         }
     }
 
+    /// Evaluate sprites in the ppu, condensing 64 sprites down to 8 sprites for a single scanline.
+    /// This function operates "asynchronously", requiring multiple calls to perform the entire job for any given scanline.
     fn sprite_eval(&mut self) {
         if self.scanline_number < 240 {
             let row = (self.scanline_number + 1) as u8;
@@ -620,7 +690,6 @@ impl NesPpu {
                     self.oamaddress = 0;
                     self.sprite_eval_mode = PpuSpriteEvalMode::Normal;
                     self.secondaryoamaddress = 0;
-                    self.numsprites = 0;
                 }
                 1..=64 => {
                     if (self.scanline_cycle & 1) == 0 {
@@ -638,11 +707,10 @@ impl NesPpu {
                                     && row >= self.oamdata
                                     && row < (self.oamdata + self.sprite_height())
                                 {
-                                    self.numsprites += 1;
                                     self.secondary_oam[self.secondaryoamaddress as usize] =
                                         self.oamdata;
                                     self.oamaddress = self.oamaddress.wrapping_add(1);
-                                    self.secondaryoamaddress = self.secondaryoamaddress + 1;
+                                    self.secondaryoamaddress += 1;
                                     self.sprite_eval_mode = PpuSpriteEvalMode::CopyCurrentSprite;
                                 } else {
                                     self.oamaddress = self.oamaddress.wrapping_add(4);
@@ -656,7 +724,6 @@ impl NesPpu {
                                     && row >= self.oamdata
                                     && row < (self.oamdata + self.sprite_height())
                                 {
-                                    self.numsprites += 1;
                                     self.sprite_eval_mode = PpuSpriteEvalMode::Done;
                                     self.registers[2] |= 0x20; //the sprite overflow flag
                                     self.oamaddress = self.oamaddress.wrapping_add(1);
@@ -671,7 +738,7 @@ impl NesPpu {
                                 self.secondary_oam[self.secondaryoamaddress as usize] =
                                     self.oamdata;
                                 self.oamaddress = self.oamaddress.wrapping_add(1);
-                                self.secondaryoamaddress = self.secondaryoamaddress + 1;
+                                self.secondaryoamaddress += 1;
                                 if (self.secondaryoamaddress & 3) == 0 {
                                     //done copying the sprite
                                     if self.oamaddress == 0 {
@@ -687,9 +754,6 @@ impl NesPpu {
                             }
                             PpuSpriteEvalMode::Done => {
                                 self.oamaddress = self.oamaddress.wrapping_add(4);
-                                if self.numsprites > 0 {
-                                    self.numsprites = 0;
-                                }
                             }
                         }
                     }
@@ -725,6 +789,7 @@ impl NesPpu {
         }
     }
 
+    /// Run a single clock cycle of the ppu
     pub fn cycle(&mut self, bus: &mut NesMotherboard) {
         if self.write_ignore_counter < PPU_STARTUP_CYCLE_COUNT {
             self.write_ignore_counter += 1;
@@ -759,15 +824,14 @@ impl NesPpu {
             } else if self.scanline_cycle <= 256 {
                 //each cycle here renders a single pixel
                 let cycle = (self.scanline_cycle - 1) as u8;
-                let bg_pixel = if self.should_render_background(cycle as u8) {
+                let bg_pixel = if self.should_render_background(cycle) {
                     let index = 7 - ((cycle) % 8);
                     let pt = self.patterntable_shift[0].to_le_bytes();
                     let upper_bit = (pt[1] >> index) & 1;
                     let lower_bit = (pt[0] >> index) & 1;
 
                     let modx = ((cycle) / 16) & 1;
-                    let mody =
-                        (((self.scanline_number as u16 + self.scrolly as u16) / 16) & 1) as u8;
+                    let mody = (((self.scanline_number + self.scrolly as u16) / 16) & 1) as u8;
                     let combined = (mody << 1) | modx;
                     let extra_palette_bits = (self.attributetable_shift[0] >> (2 * combined)) & 3;
 
@@ -795,7 +859,7 @@ impl NesPpu {
                 } else {
                     self.idle_operation(bus, cycle as u16);
                 }
-                let spr_pixel: Option<(usize, u8)> = if self.should_render_sprites(cycle as u8) {
+                let spr_pixel: Option<(usize, u8)> = if self.should_render_sprites(cycle) {
                     let mut sprite_pixels =
                         self.sprites.iter().enumerate().filter_map(|(index, e)| {
                             if cycle >= e.x && (cycle < (e.x.wrapping_add(8))) && e.y < 240 {
@@ -842,12 +906,13 @@ impl NesPpu {
 
                 let pixel = PPU_PALETTE[pixel_entry as usize];
                 self.frame_data
-                    [((self.scanline_number as u16 * 256 + cycle as u16) as u32 * 3) as usize] =
-                    pixel[0];
-                self.frame_data[((self.scanline_number as u16 * 256 + cycle as u16) as u32 * 3 + 1)
-                    as usize] = pixel[1];
-                self.frame_data[((self.scanline_number as u16 * 256 + cycle as u16) as u32 * 3 + 2)
-                    as usize] = pixel[2];
+                    [((self.scanline_number * 256 + cycle as u16) as u32 * 3) as usize] = pixel[0];
+                self.frame_data
+                    [((self.scanline_number * 256 + cycle as u16) as u32 * 3 + 1) as usize] =
+                    pixel[1];
+                self.frame_data
+                    [((self.scanline_number * 256 + cycle as u16) as u32 * 3 + 2) as usize] =
+                    pixel[2];
 
                 self.increment_scanline_cycle();
             } else if self.scanline_cycle <= 320 {
@@ -946,7 +1011,7 @@ impl NesPpu {
                 if (cycle & 1) == 0 {
                     let base = 0; //TODO calculate this correctly
                     let offset = cycle % 8; //TODO calculate this value correctly
-                    bus.ppu_cycle_1(base + offset as u16);
+                    bus.ppu_cycle_1(base + offset);
                     self.cycle1_done = true;
                 } else if self.cycle1_done {
                     bus.ppu_cycle_2_read();
@@ -986,48 +1051,47 @@ impl NesPpu {
             self.vblank_clear = false;
             self.registers[2] &= !0x80; //clear vblank flag
         }
-        self.last_nmi = self.vblank_nmi;
         self.vblank_nmi = ((self.registers[2] & 0x80) != 0)
             & ((self.registers[0] & PPU_REGISTER0_GENERATE_NMI) != 0);
     }
 
+    /// Returns true if the frame has ended. Used for frame rate synchronizing.
     pub fn get_frame_end(&mut self) -> bool {
         let flag = self.frame_end;
         self.frame_end = false;
         flag
     }
 
-    pub fn get_frame(&mut self) -> &Box<[u8; 256 * 240 * 3]> {
+    /// Returns a reference to the frame data stored in the ppu.
+    pub fn get_frame(&mut self) -> &[u8; 256 * 240 * 3] {
         &self.frame_data
     }
 
+    /// Returns the irq status for the ppu
     pub fn irq(&self) -> bool {
         self.vblank_nmi
     }
 
+    /// Converts the data in the given reference (from this module usually), into a form that sdl2 can use directly.
     #[cfg(feature = "sdl2")]
-    pub fn convert_for_sdl2(
-        f: &Box<[u8; 256 * 240 * 3]>,
-        buf: &mut Vec<egui_sdl2_gl::egui::Color32>,
-    ) {
-        let data = &**f;
-        let pixels: Vec<egui_sdl2_gl::egui::Color32> = data
+    pub fn convert_for_sdl2(f: &[u8; 256 * 240 * 3], buf: &mut Vec<egui_sdl2_gl::egui::Color32>) {
+        let pixels: Vec<egui_sdl2_gl::egui::Color32> = f
             .chunks_exact(3)
             .map(|p| egui_sdl2_gl::egui::Color32::from_rgb(p[0], p[1], p[2]))
             .collect();
         *buf = pixels;
     }
 
+    /// Converts the data in the given reference (from this module usually), into a form that egui can use directly.
     #[cfg(any(feature = "eframe", feature = "egui-multiwin"))]
-    pub fn convert_to_egui(f: &Box<[u8; 256 * 240 * 3]>) -> egui::ColorImage {
-        let data = &**f;
-        let pixels = data
+    pub fn convert_to_egui(f: &[u8; 256 * 240 * 3]) -> egui::ColorImage {
+        let pixels = f
             .chunks_exact(3)
             .map(|p| egui::Color32::from_rgb(p[0], p[1], p[2]))
             .collect();
         egui::ColorImage {
             size: [256, 240],
-            pixels: pixels,
+            pixels,
         }
     }
 }
diff --git a/nes/rust/src/romlist.rs b/nes/rust/src/romlist.rs
index 28ee11f..fe33637 100644
--- a/nes/rust/src/romlist.rs
+++ b/nes/rust/src/romlist.rs
@@ -1,25 +1,35 @@
+//! This is responsible for parsing roms from the filesystem, determining which ones are valid for the emulator to load.
+//! Emulator inaccuracies may prevent a rom that this module determines to be valid fromm operating correctly.
+
 use crate::cartridge::{CartridgeError, NesCartridge};
 use serde::{Deserialize, Serialize};
 use std::path::PathBuf;
 
+/// A single entry for a potentially valid rom for the emulator
 #[derive(Serialize, Deserialize)]
 pub struct RomListEntry {
+    /// Stores whether or not the rom is valid, and what kind of error was encountered.
     pub result: Option<Result<(), CartridgeError>>,
+    /// The time when the rom file was last modified. USed for rechecking mmodified roms.
     pub modified: Option<std::time::SystemTime>,
 }
 
+/// A list of roms for the emulator.
 #[derive(Serialize, Deserialize)]
 pub struct RomList {
+    /// The tree of roms.
     pub elements: std::collections::BTreeMap<PathBuf, RomListEntry>,
 }
 
 impl RomList {
+    /// Create a new blank list of roms
     fn new() -> Self {
         Self {
             elements: std::collections::BTreeMap::new(),
         }
     }
 
+    /// Load the rom list from disk
     pub fn load_list() -> Self {
         let contents = std::fs::read("./roms.bin");
         if let Err(_e) = contents {
@@ -30,19 +40,25 @@ impl RomList {
         config.ok().unwrap_or(RomList::new())
     }
 
+    /// Save the rom list to disk
     pub fn save_list(&self) -> std::io::Result<()> {
         let encoded = bincode::serialize(&self).unwrap();
         std::fs::write("./roms.bin", encoded)
     }
 }
 
+/// A struct for listing and parsing valid roms for the emulator.
 pub struct RomListParser {
+    /// The list of roms
     list: RomList,
+    /// True when a scan has been performed on the list of roms.
     scan_complete: bool,
+    /// True when all of the roms have been processed.
     update_complete: bool,
 }
 
 impl RomListParser {
+    /// Create a new rom list parser object. It loads the file that lists previously parsed roms.
     pub fn new() -> Self {
         Self {
             list: RomList::load_list(),
@@ -51,14 +67,12 @@ impl RomListParser {
         }
     }
 
+    /// Returns a reference to the list of roms, for presentation to the user or some other purpose.
     pub fn list(&self) -> &RomList {
         &self.list
     }
 
-    pub fn count(&self) -> usize {
-        self.list.elements.len()
-    }
-
+    /// Performs a recursive search for files in the filesystem. It currently uses all files in the specified roms folder (dir).
     pub fn find_roms(&mut self, dir: &str) {
         if !self.scan_complete {
             for entry in walkdir::WalkDir::new(dir)
@@ -71,13 +85,10 @@ impl RomListParser {
                     let m = entry.clone().into_path();
                     let name = m.clone().into_os_string().into_string().unwrap();
                     if NesCartridge::load_cartridge(name).is_ok() {
-                        if !self.list.elements.contains_key(&m) {
-                            let new_entry = RomListEntry {
-                                result: None,
-                                modified: None,
-                            };
-                            self.list.elements.insert(m, new_entry);
-                        }
+                        self.list.elements.entry(m).or_insert_with(|| RomListEntry {
+                            result: None,
+                            modified: None,
+                        });
                     }
                 }
             }
@@ -86,6 +97,7 @@ impl RomListParser {
         }
     }
 
+    /// Responsbile for checking to see if an update has been performed. An update consists of checking to see if any roms have changed since the last scan through the filesystem.
     pub fn process_roms(&mut self) {
         if !self.update_complete {
             for (p, entry) in self.list.elements.iter_mut() {
diff --git a/nes/rust/src/utility.rs b/nes/rust/src/utility.rs
index c583a52..cb59f66 100644
--- a/nes/rust/src/utility.rs
+++ b/nes/rust/src/utility.rs
@@ -1,3 +1,4 @@
+#[cfg(test)]
 pub fn convert_hex_to_decimal(d: char) -> u8 {
     match d {
         '0' => 0,
-- 
2.34.1

